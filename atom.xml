<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haxianhe&#39;s blog</title>
  
  <subtitle>最高级的自律，就是享受孤独。</subtitle>
  <link href="https://blog.haxianhe.com/atom.xml" rel="self"/>
  
  <link href="https://blog.haxianhe.com/"/>
  <updated>2022-01-06T12:50:22.236Z</updated>
  <id>https://blog.haxianhe.com/</id>
  
  <author>
    <name>haxianhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021 年终总结</title>
    <link href="https://blog.haxianhe.com/2022/01/06/Summary/2021-summary/"/>
    <id>https://blog.haxianhe.com/2022/01/06/Summary/2021-summary/</id>
    <published>2022-01-06T12:50:00.000Z</published>
    <updated>2022-01-06T12:50:22.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>2021年工作上最大的变化就是年初换了工作，从待了两年半的上家公司离开了，来了快手。</p><h3 id="跳槽快手"><a href="#跳槽快手" class="headerlink" title="跳槽快手"></a>跳槽快手</h3><p>年初的时候面了很多家公司，最后接了快手的offer。</p><p>先说说为什么要换工作，主要有两点考虑：</p><ol><li>为了薪资，适当跳槽可以拿到更客观的薪资。</li><li>工作上遇到了瓶颈，党哥之前一直要求在稳定性上做更多的工作。但是一直没有懂怎么做。所以想换一个环境去学习。</li></ol><p>面试后总结，写的文章：</p><ul><li><a href="https://blog.haxianhe.com/2021/02/27/CS-Interview/social-interview/">涨薪50%，从小厂逆袭快手 - 附面经</a></li><li><a href="https://blog.haxianhe.com/2021/03/04/CS-Interview/how-to-ready-interview/">从小厂逆袭快手，我是如何准备面试的</a></li><li><a href="https://blog.haxianhe.com/2021/04/21/CS-Interview/from_php2java/">从小厂逆袭快手，我是如何从PHP转Java的</a></li></ul><h3 id="转正"><a href="#转正" class="headerlink" title="转正"></a>转正</h3><p>转正前自己压力非常大，因为当时正在降本增效，很担心自己被裁掉…还好最后还是过了。</p><h3 id="职业化"><a href="#职业化" class="headerlink" title="职业化"></a>职业化</h3><p>但是，转正后第一次沟通绩效也遇到了之前在顺丰时的问题：“1.技术能力有待加强。2.做事情需要更仔细，考虑更周到，简单来说就是最高标准。3.就是对外沟通方面做的比较好。”。</p><p>事后，结合自己换工作以来的一些思考以及学习的课程，知道了自己面对的问题——职业化。</p><p>职业化，被最大程度误解的一个词，职业化意味着你从原来的父子模式（你给我钱，给我空间，我去成长）、师生模式（你是老师，我是学生，你教我，我学）到交易模式（我出卖我的智力、体力、能力，你给我报酬）的转变。</p><p>对事：</p><ul><li>能不能在一张A4纸上把业务工作流程画出来，能不能把业务对接的上、下游流程画出来</li><li>明确你是来解决什么问题的，然后把它解决好（技术、需求、线上稳定性）<br>对人：</li><li>每周请一个新的人吃饭，弱关系</li></ul><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>21年读书没有达成目标，这一年只看了《原则》《被讨厌的勇气》这两本书，今年上半年主要在忙着换工作，适应新的工作环境，下半年主要在忙着转正的事，此外这一年也挺折腾的，作息也不是很规律，22年还是要调整回原来的状态的✊。</p><p>21年的读书笔记</p><ul><li><a href="https://blog.haxianhe.com/2021/09/08/Book-Notes-Self/%E5%8E%9F%E5%88%99/">以史为鉴 - 读《原则》</a></li><li><a href="https://blog.haxianhe.com/2021/10/26/Book-Notes-Psycholog/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/">人是可以改变的-读《被讨厌的勇气》</a></li></ul><h2 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h2><p>健身也没有完成目标，21年一方面调整一下设置目标的方式，另一方面降低一下目标阈值，先保证目标具有可完成性。</p><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>21年旅行目标几乎完成（有两座城市不是第一次去…）</p><p>21年去过的城市：</p><ul><li>广州 </li><li>青岛</li><li>长沙</li><li>杭州</li><li>重庆</li></ul><h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><p>21年年初又一波大的亏损，亏了几万块钱。后面投资策略就彻底放弃了哪些乱七八糟的技巧了。</p><p>目前主要投资有两个：</p><ol><li>我要稳稳的幸福定投，有闲钱全部投到这个上。</li><li>指数基金，主要投资标的：沪深300、中证500、中证红利、上证50、深证100、创业板50、兴全合润、富国天惠、恒生ETF、恒生科技、标普500、纳斯达克100、中概互联。</li></ol><h2 id="21年目标回顾"><a href="#21年目标回顾" class="headerlink" title="21年目标回顾"></a>21年目标回顾</h2><ul><li>技术-学习：从项目经验、技术原理、基础知识等三个角度去点亮自己的技术地图，坚持 <a href="https://leetcode-cn.com/progress/" target="_blank" rel="noopener">每天刷一道 LeetCode 上的题目</a>。<ul><li>没完成，差的太多。</li></ul></li><li>投资：继续坚持基金定投，目标 <strong>年化收益达到30%</strong> 。<ul><li>没完成，差的太多。</li></ul></li><li>写作：以技术为主线 <strong>坚持每周发表一篇文章</strong>。<ul><li>没完成，差的太多。</li></ul></li><li>读书：读书还是要坚持下去的，<strong>坚持每周读一本书</strong>。<ul><li>没完成，差的太多</li></ul></li><li>健身：身体才是一切的基础，没有一个好身体一切都是空谈，<strong>每周练三次，每次一个小时</strong>。<ul><li>没完成，差的太多。</li></ul></li><li>旅行：旅行是最好的放松方式，目标 <strong>去3个自己没去过的城市</strong>。<ul><li>基本完成。</li></ul></li></ul><h2 id="22年目标"><a href="#22年目标" class="headerlink" title="22年目标"></a>22年目标</h2><ul><li>读书24本</li><li>健身96次</li><li>旅行去2个没去过的省份</li><li>理财<ul><li>定投账户 - 年化5%</li><li>100份账户 - 不亏钱</li></ul></li><li>考研</li><li>写作24篇<h2 id="个人-Milestone"><a href="#个人-Milestone" class="headerlink" title="个人 Milestone"></a>个人 Milestone</h2></li><li>跳槽快手</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h2&gt;&lt;p&gt;2021年工作上最大的变化就是年初换了工作，从待了两年半的上家公司离开了，来了快手。&lt;/p&gt;
&lt;h3 id=&quot;跳槽快手&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Summary" scheme="https://blog.haxianhe.com/categories/Summary/"/>
    
    
    <category term="年终总结" scheme="https://blog.haxianhe.com/tags/年终总结/"/>
    
  </entry>
  
  <entry>
    <title>人是可以改变的-读《被讨厌的勇气》</title>
    <link href="https://blog.haxianhe.com/2021/10/26/Book-Notes-Psycholog/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/"/>
    <id>https://blog.haxianhe.com/2021/10/26/Book-Notes-Psycholog/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/</id>
    <published>2021-10-25T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.756Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20211026154512.png" alt></p><p>《被讨厌的勇气》<br>作者：【日】安见一郎 古贺史健<br>译者：渠海峡<br>出版社：北京，机械工业出版社，2015</p><hr><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>首先我们来介绍一下阿德勒的个体心理学是什么。</p><h2 id="与弗洛伊德心理创伤学说的区别"><a href="#与弗洛伊德心理创伤学说的区别" class="headerlink" title="与弗洛伊德心理创伤学说的区别"></a>与弗洛伊德心理创伤学说的区别</h2><table><thead><tr><th>个体心理学</th><th>解释</th><th>心理创伤学说</th><th>解释</th></tr></thead><tbody><tr><td>目的论</td><td>为了达成目的，赋予经历以意义</td><td>原因论</td><td>因为过去的某段经历所以痛苦</td></tr><tr><td>整体论</td><td>-</td><td>二元论</td><td>-</td></tr><tr><td>此时此刻</td><td>-</td><td>纠结过去</td><td>-</td></tr></tbody></table><p><strong>目的论 VS 原因论</strong></p><p>弗洛伊德主张“<strong>原因论</strong>”，即你之所以痛苦是因为过去的某段经历。而阿德勒主张的是“<strong>目的论</strong>”，即你为了达成你的“目的”，赋予了你过去经历以某种意义。</p><p>在“人是可以改变的”这个前提下，每个人的生活方式（世界观、人生观）是自己选择的。而正因为生活方式是自己选择的，那就可以重新进行选择。</p><p><strong>整体论 VS 二元论</strong></p><p>把人看作不可分割的存在和作为“整体的我”来考虑的方式叫作“整体论”。</p><p><strong>此时此刻 VS 纠结过去</strong></p><p>因为过去和未来根本不存在，所以才要谈现在。起决定作用的既不是昨天也不是明天，而是“此时此刻”。</p><h2 id="勇气的心理学"><a href="#勇气的心理学" class="headerlink" title="勇气的心理学"></a>勇气的心理学</h2><ul><li>被讨厌的勇气</li><li>甘于平凡的勇气</li><li>获得幸福的勇气<ul><li>幸福即贡献感</li><li>前提：自由，不再寻求认可</li></ul></li></ul><h2 id="提出目标"><a href="#提出目标" class="headerlink" title="提出目标"></a>提出目标</h2><ul><li>行为方面的目标<ul><li>自立</li><li>与社会和谐共处</li></ul></li><li>支撑这种行为的心理方面目标<ul><li>“我有能力”的意识</li><li>“人人都是我的伙伴”的意识</li></ul></li></ul><h1 id="“病因”人际关系"><a href="#“病因”人际关系" class="headerlink" title="“病因”人际关系"></a>“病因”人际关系</h1><p>人际关系是一切的烦恼之源。</p><h2 id="烦恼来源"><a href="#烦恼来源" class="headerlink" title="烦恼来源"></a>烦恼来源</h2><p><strong>追求优越性</strong>：人无力的存活在这个世界上，并且希望摆脱这种状态，继而就有了普遍欲求。可以理解为“希望进步”、“追求理想状态”。</p><p><strong>自卑感</strong>：人追求优越性这一“希望进步的状态”之中，树立某写理想或目标并努力为之奋斗。同时对于无法达成理想的自己就会产生一种自卑感。</p><p><strong>自卑情结</strong>：指把自己的自卑感当作某种借口使用的状态。具体就像“我因为学历低所以无法成功”之类的。</p><p><strong>夸耀不幸</strong>：以自己的不幸来支配对方。</p><h2 id="矛盾起源"><a href="#矛盾起源" class="headerlink" title="矛盾起源"></a>矛盾起源</h2><p><strong>基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。</strong></p><h2 id="人生课题"><a href="#人生课题" class="headerlink" title="人生课题"></a>人生课题</h2><ul><li>工作课题</li><li>交友课题</li><li>爱的课题</li></ul><p>人生最大的谎言就是逃避人生课题。</p><h1 id="“处方”解决方式"><a href="#“处方”解决方式" class="headerlink" title="“处方”解决方式"></a>“处方”解决方式</h1><h2 id="入口-出发点：课题分离"><a href="#入口-出发点：课题分离" class="headerlink" title="入口/出发点：课题分离"></a>入口/出发点：课题分离</h2><p>我们必须从“这是谁的课题”这一观点出发，把自己的课题与别人的课题分离开来。</p><p><strong>辨别方法：只需要考虑“某种选择带来的结果最终要由谁来承担”</strong></p><p>可以把马带到水边，但不能强迫其喝水。</p><p>能改变自己的只有自己。</p><h2 id="支撑点-基本原理：横向关系"><a href="#支撑点-基本原理：横向关系" class="headerlink" title="支撑点/基本原理：横向关系"></a>支撑点/基本原理：横向关系</h2><p>阿德勒心理学反对一切纵向关系，提倡把所有的人际关系都看作横向关系。</p><h2 id="终极目标：共同体感觉"><a href="#终极目标：共同体感觉" class="headerlink" title="终极目标：共同体感觉"></a>终极目标：共同体感觉</h2><ul><li>自我接纳</li><li>他者信赖</li><li>他者贡献</li></ul><p><strong>通过他者贡献让自己有“我对共同体有用”的主观体会-&gt;感觉到自己的价值-&gt;获得勇气</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20211026154512.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;《被讨厌的勇气》&lt;br&gt;作者：【日】安见一郎 古贺史健&lt;br&gt;译者</summary>
      
    
    
    
    <category term="Book-Notes" scheme="https://blog.haxianhe.com/categories/Book-Notes/"/>
    
    
    <category term="心理学" scheme="https://blog.haxianhe.com/tags/心理学/"/>
    
  </entry>
  
  <entry>
    <title>破壁MySQL - 其他问题</title>
    <link href="https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-07/"/>
    <id>https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-07/</id>
    <published>2021-09-24T23:00:07.000Z</published>
    <updated>2021-11-23T12:50:38.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote><p>在实际业务中经常会使用到 JSON 数据类型，在查询过程中主要有两种使用需求：</p><ol><li>在 where 条件中有通过 json 中的某个字段去过滤返回结果的需求</li><li>查询 json 字段中的部分字段作为返回结果（减少内存占用）</li></ol></blockquote><h2 id="JSON-CONTAINS"><a href="#JSON-CONTAINS" class="headerlink" title="JSON_CONTAINS"></a>JSON_CONTAINS</h2><p><strong>JSON_CONTAINS(target, candidate[, path])</strong></p><p><strong>如果在 json 字段 target 指定的位置 path，找到了目标值 condidate，返回 1，否则返回 0</strong></p><p><strong>如果只是检查在指定的路径是否存在数据，使用JSON_CONTAINS_PATH()</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET @j = '&#123;"a": 1, "b": 2, "c": &#123;"d": 4&#125;&#125;';</span><br><span class="line">mysql&gt; SET @j2 = '1';</span><br><span class="line">mysql&gt; SELECT JSON_CONTAINS(@j, @j2, '$.a');</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| JSON_CONTAINS(@j, @j2, '$.a') |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">|                             1 |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">mysql&gt; SELECT JSON_CONTAINS(@j, @j2, '$.b');</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| JSON_CONTAINS(@j, @j2, '$.b') |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">|                             0 |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SET @j2 = '&#123;"d": 4&#125;';</span><br><span class="line">mysql&gt; SELECT JSON_CONTAINS(@j, @j2, '$.a');</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| JSON_CONTAINS(@j, @j2, '$.a') |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">|                             0 |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">mysql&gt; SELECT JSON_CONTAINS(@j, @j2, '$.c');</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">| JSON_CONTAINS(@j, @j2, '$.c') |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br><span class="line">|                             1 |</span><br><span class="line">+<span class="comment">-------------------------------+</span></span><br></pre></td></tr></table></figure><h2 id="JSON-CONTAINS-PATH"><a href="#JSON-CONTAINS-PATH" class="headerlink" title="JSON_CONTAINS_PATH"></a>JSON_CONTAINS_PATH</h2><p><strong>JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] …)</strong></p><p><strong>如果在指定的路径存在数据返回 1，否则返回 0</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET @j = '&#123;"a": 1, "b": 2, "c": &#123;"d": 4&#125;&#125;';</span><br><span class="line">mysql&gt; SELECT JSON_CONTAINS_PATH(@j, 'one', '$.a', '$.e');</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| JSON_CONTAINS_PATH(@j, 'one', '$.a', '$.e') |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">|                                           1 |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">mysql&gt; SELECT JSON_CONTAINS_PATH(@j, 'all', '$.a', '$.e');</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| JSON_CONTAINS_PATH(@j, 'all', '$.a', '$.e') |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">|                                           0 |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">mysql&gt; SELECT JSON_CONTAINS_PATH(@j, 'one', '$.c.d');</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| JSON_CONTAINS_PATH(@j, 'one', '$.c.d') |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">|                                      1 |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">mysql&gt; SELECT JSON_CONTAINS_PATH(@j, 'one', '$.a.d');</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">| JSON_CONTAINS_PATH(@j, 'one', '$.a.d') |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br><span class="line">|                                      0 |</span><br><span class="line">+<span class="comment">----------------------------------------+</span></span><br></pre></td></tr></table></figure><p>实际使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$conds = <span class="keyword">new</span> Criteria();</span><br><span class="line">$conds-&gt;andWhere(<span class="string">'dept_code'</span>, <span class="string">'in'</span>, $deptCodes);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($aoiAreaId)) &#123;</span><br><span class="line">    $aoiAreaIdCond = <span class="keyword">new</span> Criteria();</span><br><span class="line">    $aoiAreaIdCond-&gt;orWhere(<span class="string">"JSON_CONTAINS_PATH(new_aoi_area_ids,'one', '$.\"$aoiAreaId\"')"</span>, <span class="string">'='</span>, <span class="number">1</span>);</span><br><span class="line">    $aoiAreaIdCond-&gt;orWhere(<span class="string">"JSON_CONTAINS_PATH(old_aoi_area_ids,'one', '$.\"$aoiAreaId\"')"</span>, <span class="string">'='</span>, <span class="number">1</span>);</span><br><span class="line">    $conds-&gt;andWhere($aoiAreaIdCond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="column-gt-path、column-gt-gt-path"><a href="#column-gt-path、column-gt-gt-path" class="headerlink" title="column-&gt;path、column-&gt;&gt;path"></a>column-&gt;path、column-&gt;&gt;path</h2><p><strong>获取指定路径的值</strong></p><p><strong>-&gt; vs -&gt;&gt;</strong></p><p>Whereas the -&gt; operator simply extracts a value, the -&gt;&gt; operator in addition unquotes the extracted result.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM jemp WHERE g &gt; 2;</span><br><span class="line">+<span class="comment">-------------------------------+------+</span></span><br><span class="line">| c                             | g    |</span><br><span class="line">+<span class="comment">-------------------------------+------+</span></span><br><span class="line">| &#123;"id": "3", "name": "Barney"&#125; |    3 |</span><br><span class="line">| &#123;"id": "4", "name": "Betty"&#125;  |    4 |</span><br><span class="line">+<span class="comment">-------------------------------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> c-&gt;<span class="string">'$.name'</span> <span class="keyword">AS</span> <span class="keyword">name</span></span><br><span class="line">    -&gt;     <span class="keyword">FROM</span> jemp <span class="keyword">WHERE</span> g &gt; <span class="number">2</span>;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| name     |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| "Barney" |</span><br><span class="line">| "Betty"  |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> JSON_UNQUOTE(c-&gt;<span class="string">'$.name'</span>) <span class="keyword">AS</span> <span class="keyword">name</span></span><br><span class="line">    -&gt;     <span class="keyword">FROM</span> jemp <span class="keyword">WHERE</span> g &gt; <span class="number">2</span>;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| name   |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| Barney |</span><br><span class="line">| Betty  |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> c-&gt;&gt;<span class="string">'$.name'</span> <span class="keyword">AS</span> <span class="keyword">name</span></span><br><span class="line">    -&gt;     <span class="keyword">FROM</span> jemp <span class="keyword">WHERE</span> g &gt; <span class="number">2</span>;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| name   |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| Barney |</span><br><span class="line">| Betty  |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>实际使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$retTask = AoiAreaTaskOrm::findRows([<span class="string">'status'</span>, <span class="string">'extra_info-&gt;&gt;"$.new_aoi_area_infos" as new_aoi_area_infos'</span>, <span class="string">'extra_info-&gt;&gt;"$.old_aoi_area_infos" as old_aoi_area_infos'</span>], $cond);</span><br></pre></td></tr></table></figure><h1 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p><strong>第一范式 (1NF)</strong></p><p>属性不可分。</p><p><strong>第二范式 (2NF)</strong></p><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong></p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt;  Grade</li></ul><p><strong>第三范式 (3NF)</strong></p><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><h1 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h2 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122154629.png" alt></p><h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="https://raw.githubusercontent.com/haxianhe/pic/master/image/20200520092446.png" alt></p><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122154642.png" alt></p><h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122154659.png" alt></p><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在实际业务中经常会使用到 JSON 数据类型，在查询过程中主要有两种使用需求：&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    <category term="CS-Middleware" scheme="https://blog.haxianhe.com/categories/CS-Middleware/"/>
    
    
    <category term="mysql" scheme="https://blog.haxianhe.com/tags/mysql/"/>
    
    <category term="《破壁MySQL》" scheme="https://blog.haxianhe.com/tags/《破壁MySQL》/"/>
    
  </entry>
  
  <entry>
    <title>破壁MySQL - 主从复制</title>
    <link href="https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-06/"/>
    <id>https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-06/</id>
    <published>2021-09-24T22:00:06.000Z</published>
    <updated>2021-11-23T12:50:38.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li>I/O 线程 ：负责从主服务器上读取- 二进制日志，并写入从服务器的中继日志（Relay log）。</li><li>SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122154402.png" alt></p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122154435.png" alt></p><h1 id="如何解决主从延迟问题"><a href="#如何解决主从延迟问题" class="headerlink" title="如何解决主从延迟问题"></a>如何解决主从延迟问题</h1><ol><li>强制读主库。</li><li>加缓存</li><li>强同步。</li></ol><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h1&gt;&lt;p&gt;主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binlog 线程 ：负责将</summary>
      
    
    
    
    <category term="CS-Middleware" scheme="https://blog.haxianhe.com/categories/CS-Middleware/"/>
    
    
    <category term="mysql" scheme="https://blog.haxianhe.com/tags/mysql/"/>
    
    <category term="《破壁MySQL》" scheme="https://blog.haxianhe.com/tags/《破壁MySQL》/"/>
    
  </entry>
  
  <entry>
    <title>破壁MySQL - 分库分表</title>
    <link href="https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-05/"/>
    <id>https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-05/</id>
    <published>2021-09-24T21:00:05.000Z</published>
    <updated>2021-11-23T12:50:38.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>怎么实现的分库分表</p></blockquote><h1 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h1><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122154319.png" alt></p><h1 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h1><p>垂直切分是将一张表按列分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直气氛将经常被使用的列喝不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不通的库中，例如将原来电商数据部署库垂直切分称商品数据库、用户数据库等。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122154333.png" alt></p><h1 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h1><ul><li>哈希取模：hash(key)%N</li><li>范围：可以是 ID 范围也可以是时间范围</li><li>映射表：使用单独的一个数据库来存储映射关系</li></ul><h1 id="Sharding-存在的问题"><a href="#Sharding-存在的问题" class="headerlink" title="Sharding 存在的问题"></a>Sharding 存在的问题</h1><p><strong>事务问题</strong></p><p>使用分布式事务来解决，比如 XA 接口</p><p><strong>连接</strong></p><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><p><strong>唯一性</strong></p><ul><li>使用全局唯一 ID （GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器（如 Twitter 的 Snowflake 算法）</li></ul><ul><li><a href="https://xie.infoq.cn/article/200e90b980e8fec1ad6850878" target="_blank" rel="noopener">Mysql 学习笔记：分库分表 (sharding)</a></li><li><a href="https://juejin.cn/post/6908220694929080333" target="_blank" rel="noopener">炸！业界难题，跨库分页的几种常见方案</a></li><li><a href="https://xie.infoq.cn/article/10a98e12934a048ed80d36450" target="_blank" rel="noopener">百亿级数据分表后怎么分页查询？</a></li></ul><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;怎么实现的分库分表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;水平切分&quot;&gt;&lt;a href=&quot;#水平切分&quot; class=&quot;headerlink&quot; title=&quot;水平切分&quot;&gt;&lt;/a&gt;水平切分&lt;/h1&gt;&lt;p&gt;水平切分又称为 Sharding，它</summary>
      
    
    
    
    <category term="CS-Middleware" scheme="https://blog.haxianhe.com/categories/CS-Middleware/"/>
    
    
    <category term="mysql" scheme="https://blog.haxianhe.com/tags/mysql/"/>
    
    <category term="《破壁MySQL》" scheme="https://blog.haxianhe.com/tags/《破壁MySQL》/"/>
    
  </entry>
  
  <entry>
    <title>破壁MySQL - 性能优化</title>
    <link href="https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-04/"/>
    <id>https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-04/</id>
    <published>2021-09-24T20:00:04.000Z</published>
    <updated>2021-11-23T12:50:38.768Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章 <a href="https://haxianhe.com/2021/01/30/CS-Technical-mysql/break-mysql-index/" target="_blank" rel="noopener">「《破壁MySQL》 - MySQL索引」</a> 中我们简单介绍了MySQL 索引的相关知识，那么在这一篇文章中我们主要介绍的是 <strong>MySQL 性能优化的常用方案</strong>，文章中在每介绍一部分知识点后都会给出<strong>知识点相对应的常见面试题以及答案</strong>，达到理论和实践相结合的效果。</p><blockquote><p><strong>面试题1: 分页查询到后期耗时很大怎么办？</strong></p></blockquote><p>Mysql的优化，大体可以分为三部分：索引的优化，sql语句的优化，表的优化</p><h1 id="优化慢查询的步骤"><a href="#优化慢查询的步骤" class="headerlink" title="优化慢查询的步骤"></a>优化慢查询的步骤</h1><p>0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE</p><p>1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</p><p>2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</p><p>3.order by limit 形式的sql语句让排序的表优先查</p><p>4.了解业务方使用场景</p><p>5.加索引时参照建索引的几大原则</p><p>6.观察结果，不符合预期继续从0分析</p><h1 id="使用-explain-分析-select-查询语句"><a href="#使用-explain-分析-select-查询语句" class="headerlink" title="使用 explain 分析 select 查询语句"></a>使用 explain 分析 select 查询语句</h1><blockquote><p>explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p></blockquote><h2 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h2><p>常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY 子查询等。</p><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>要查询的表</p><h2 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h2><blockquote><p>The possible indexes to choose</p></blockquote><p>可选择的索引</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><blockquote><p>The index actually chosen</p></blockquote><p>实际使用的索引</p><h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><blockquote><p>Estimate of rows to be examined</p></blockquote><p>扫描的行数</p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>索引查询类型，经常用到的索引查询类型：</p><p><strong>const：使用主键或者唯一索引进行查询的时候只有一行匹配<br>ref：使用非唯一索引<br>range：使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询<br>index：和all的区别是扫描的是索引树<br>all：扫描全表：</strong></p><p><strong>system</strong></p><p><strong>触发条件：表只有一行，这是一个 const type 的特殊情况</strong></p><p><strong>const</strong></p><p><strong>触发条件：在使用主键或者唯一索引进行查询的时候只有一行匹配。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> primary_key_part1=<span class="number">1</span> <span class="keyword">AND</span> primary_key_part2=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122153816.png" alt></p><p><strong>eq_ref</strong></p><p><strong>触发条件：在进行联接查询的，使用主键或者唯一索引并且只匹配到一行记录的时候</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>ref</strong></p><p>触发条件：使用非唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column=expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122153852.png" alt></p><p><strong>range</strong></p><p><strong>触发条件：只有在使用主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询才是 range</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 = <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122153917.png" alt></p><p><strong>index</strong></p><blockquote><p>The index join type is the same as ALL, except that the index tree is scanned. This occurs two ways:</p></blockquote><p>触发条件：</p><p>只扫描索引树</p><p>1）查询的字段是索引的一部分，覆盖索引。<br>2）使用主键进行排序</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122153941.png" alt></p><p><strong>all</strong></p><p>触发条件：全表扫描，不走索引</p><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p>关于索引原理在另一篇文章中有单独的介绍，这里就省略了。</p><h2 id="索引建立的原则"><a href="#索引建立的原则" class="headerlink" title="索引建立的原则"></a>索引建立的原则</h2><p>1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。 </p><p>3.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p><p>4.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p><p>5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p><strong>索引不能是表达式的一部分</strong></p><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p><strong>多个字段最好建立联合索引</strong></p><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h2><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="不走索引的情况"><a href="#不走索引的情况" class="headerlink" title="不走索引的情况"></a>不走索引的情况</h2><ul><li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)</li><li>对于联合索引，不是使用的第一部分(第一个)，则不会使用索引</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引（值类型不同）</li></ul><h1 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h1><h2 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h2><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h2 id="减少服务器端扫描的行数"><a href="#减少服务器端扫描的行数" class="headerlink" title="减少服务器端扫描的行数"></a>减少服务器端扫描的行数</h2><p>最有效的方式是使用索引来覆盖查询。</p><h1 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h1><h2 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h2><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    <span class="string">"DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h2><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id=tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag=<span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇文章 &lt;a href=&quot;https://haxianhe.com/2021/01/30/CS-Technical-mysql/break-mysql-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「《破壁MySQL》 - MySQL索</summary>
      
    
    
    
    <category term="CS-Middleware" scheme="https://blog.haxianhe.com/categories/CS-Middleware/"/>
    
    
    <category term="mysql" scheme="https://blog.haxianhe.com/tags/mysql/"/>
    
    <category term="《破壁MySQL》" scheme="https://blog.haxianhe.com/tags/《破壁MySQL》/"/>
    
  </entry>
  
  <entry>
    <title>破壁MySQL - 事务</title>
    <link href="https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-03/"/>
    <id>https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-03/</id>
    <published>2021-09-24T19:00:03.000Z</published>
    <updated>2021-11-23T12:50:38.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>事务的四个特性是什么？</li><li>Mysql的四种隔离级别以及带来的问题</li><li>MVCC熟悉吗，它的底层原理？</li><li>InnoDB 是如何解决幻读？原理？</li><li>介绍一下InnoDB的日志？</li><li>InnoDB的事务是如何实现的</li><li>事务的实现原理</li><li>InnoDB 是如何保证事务的原子性的/持久性？</li></ul></blockquote><p>事务是指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>事务最基本的莫过于 ACID 四个特性了，这四个特性分别是：</p><ul><li>Atomicity：原子性</li><li>Consistency：一致性</li><li>Isolation：隔离性</li><li>Durability：持久性</li></ul><p><strong>原子性</strong></p><p>事务被视为不可分割的最小单元，事务的所有操作要么全部成功，要么全部失败回滚。</p><p><strong>一致性</strong></p><p>数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><p><strong>隔离性</strong></p><p>一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><p><strong>持久性</strong></p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢。</p><h2 id="ACID-之间的关系"><a href="#ACID-之间的关系" class="headerlink" title="ACID 之间的关系"></a>ACID 之间的关系</h2><p><strong>执行结果正确 = 一致性 = 原子性 + 隔离性</strong></p><p><strong>应对数据库崩溃 = 持久性</strong></p><p>事务的 ACID 特性概念很简单，但不好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122141348.png" alt></p><h2 id="InnoDB-如何实现-ACID-的特性"><a href="#InnoDB-如何实现-ACID-的特性" class="headerlink" title="InnoDB 如何实现 ACID 的特性"></a>InnoDB 如何实现 ACID 的特性</h2><p>事务的隔离性由 Next-Key Lock 实现，redo log 用来保证事务的原子性和持久性，undo log 用来保证事务的一致性。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p><strong>未提交读（READ UNCOMMITTED）</strong></p><p>事务中的修改，即使没有提交，对其他事务也是可见的。</p><p><strong>提交读（READ COMMITTED）</strong></p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。</p><p><strong>可重复读（REPEATABLE READ）</strong></p><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><p><strong>可串行化（SERIALIZABLE）</strong></p><p>强制事务串行执行。</p><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻影读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可串行化</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><blockquote><ol><li>事务的隔离级别定义的的是当前读。</li><li>InnoDB在可重复读级别下的当前读通过Next-Key Lock锁机制解决了幻读问题。</li><li>InnoDB在可重复读级别下的快照读存在“幻读”问题，解决方案是（1）改为可串行化隔离级别（2）改为当前读（读操作加锁）</li></ol></blockquote><h1 id="事务并发处理带来的问题"><a href="#事务并发处理带来的问题" class="headerlink" title="事务并发处理带来的问题"></a>事务并发处理带来的问题</h1><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>脏读指的是不同事务下，当前事务可以读取到另外事务未提交的数据。</p><p>例如：</p><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122141708.png" alt></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>不可重复读指的是同一事务内多次读取同一数据集合，读取到的数据是不一样的情况。</p><p>例如：</p><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122141903.png" alt></p><h2 id="Phantom-Proble（幻影读）"><a href="#Phantom-Proble（幻影读）" class="headerlink" title="Phantom Proble（幻影读）"></a>Phantom Proble（幻影读）</h2><p>Phantom Proble 是指在同一事务下，连续执行两次同样的 sql 语句可能返回不同的结果，第二次的 sql 语句可能会返回之前不存在的行。</p><p>幻影读是一种特殊的不可重复读问题。</p><h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><p>一个事务的更新操作会被另一个事务的更新操作所覆盖。</p><p>例如：</p><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122142001.png" alt></p><p>这类型问题可以通过给 SELECT 操作加上排他锁来解决，不过这可能会引入性能问题，具体使用要视业务场景而定。</p><h1 id="“读”"><a href="#“读”" class="headerlink" title="“读”"></a>“读”</h1><p>在可重复读级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。</p><p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p><h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ….;</span><br></pre></td></tr></table></figure><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br></pre></td></tr></table></figure><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line">- <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>事务的隔离级别实际上都是定义的当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”的隔离性，就需要通过加锁来实现了。</p><h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>版本号</strong></p><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><p><strong>隐藏的列</strong></p><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><p><strong>Undo 日志</strong></p><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122142253.png" alt></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p><p>当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p><p><strong>SELECT</strong></p><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><p><strong>INSERT</strong></p><p>将当前系统版本号作为数据行快照的创建版本号。</p><p><strong>DELETE</strong></p><p>将当前系统版本号作为数据行快照的删除版本号。</p><p><strong>UPDATE</strong></p><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。</p><h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><p><strong>共享锁（S Lock）</strong></p><p>允许事务读一行数据</p><p><strong>排他锁（X Lock）</strong></p><p>允许事务删除或者更新一行数据</p><p><strong>意向共享锁（IS Lock）</strong></p><p>事务想要获得一张表中某几行的共享锁</p><p><strong>意向排他锁</strong></p><p>事务想要获得一张表中某几行的排他锁</p><h2 id="锁算法"><a href="#锁算法" class="headerlink" title="锁算法"></a>锁算法</h2><p><strong>Record Lock</strong></p><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><p><strong>Gap Lock</strong></p><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><strong>Next-Key Lock</strong></p><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure><h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><h2 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h2><p><strong>作用</strong></p><p>确保事务的原子性和持久性。</p><p>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p><p><strong>内容</strong></p><p>物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</p><p><strong>什么时候产生</strong></p><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p><p><strong>什么时候释放</strong></p><p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p><p><strong>对应的物理文件</strong></p><p>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2</p><ul><li>innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。　　</li><li>innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2　　</li></ul><p>关于文件的大小和数量，由一下两个参数配置</p><ul><li>innodb_log_file_size 重做日志文件的大小。　　</li><li>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1其他：　　</li></ul><p>很重要一点，redo log是什么时候写盘的？</p><p>前面说了是在事物开始之后逐步写盘的。</p><p>之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M)，Innodb存储引擎先将重做日志写入innodb_log_buffer中。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122144208.png" alt></p><p><strong>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘：</strong>　　</p><ol><li>Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</li><li>每个事务提交时会将重做日志刷新到重做日志文件。</li><li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件。</li></ol><p>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。　　</p><blockquote><p>另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：”即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。”这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p></blockquote><h2 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h2><p><strong>作用</strong></p><p><strong>保存了事务发生之前的数据的一个版本</strong>（比如一条 INSERT 语句，对应一条 DELETE 的 undo log ，对于每个 UPDATE 语句，对应一条相反的 UPDATE 的 undo log），<strong>可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</strong></p><p><strong>内容</strong></p><p>逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的。</p><p><strong>什么时候产生</strong></p><p>事务开始之前，将当前的版本生成undo log，undo 也会产生 redo 来保证undo log的持久性。</p><p><strong>什么时候释放</strong></p><p>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p><p><strong>对应的物理文件</strong></p><p>MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。</p><p>MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数，如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</p><p>关于MySQL5.7之后的独立undo 表空间配置参数如下：</p><ul><li>innodb_undo_directory = /data/undospace/ –undo独立表空间的存放目录</li><li>innodb_undo_logs = 128 –回滚段为128KB</li><li>innodb_undo_tablespaces = 4 –指定有4个undo log文件</li></ul><p>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122151810.png" alt></p><p><strong>其他</strong></p><p>undo log是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redo log的产生。</p><p>默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。</p><p>因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。</p><p>因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><strong>作用</strong></p><ol><li><strong>复制</strong>：在主从同步中，从库利用主库上的 binlog 进行重放，实现主从同步。</li><li><strong>恢复</strong>：用于数据库的基于时间点的还原。</li></ol><p><strong>内容</strong></p><p>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。</p><p>但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）信息。</p><p>在使用mysqlbinlog解析binlog之后一些都会真相大白。</p><p>因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。</p><p><strong>什么时候产生</strong></p><p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p><p>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</p><p>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。</p><p>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p><p><strong>什么时候释放</strong></p><p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122153238.png" alt><br>　　<br><strong>对应的物理文件</strong></p><p>配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</p><p>对于每个binlog日志文件，通过一个统一的index文件来组织。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122153301.png" alt></p><p><strong>其他</strong></p><p>二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同</p><ol><li>作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。<br>2.内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</li><li>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。<br>4.恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</li></ol><p>关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的。</p><p>MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p><h2 id="redo-log-amp-undo-log总结"><a href="#redo-log-amp-undo-log总结" class="headerlink" title="redo log &amp; undo log总结"></a>redo log &amp; undo log总结</h2><p>下面是redo log + undo log的简化过程，便于理解两种日志的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设有A、B两个数据，值分别为1,2.</span><br><span class="line">1. 事务开始</span><br><span class="line">2. 记录A=1的 undo log 到 redo log</span><br><span class="line">3. 记录A=1到 undo log</span><br><span class="line">4. 修改A=3</span><br><span class="line">5. 记录A=3到 redo log</span><br><span class="line">6. 记录B=2的 undo log到 redo log</span><br><span class="line">7. 记录B=2到 undo log</span><br><span class="line">8. 修改B=4</span><br><span class="line">9. 记录B=4到redo log</span><br><span class="line">10. 将redo log写入磁盘</span><br><span class="line">11. 事务提交</span><br></pre></td></tr></table></figure><h2 id="redo-log-和-bin-log-的区别"><a href="#redo-log-和-bin-log-的区别" class="headerlink" title="redo log 和 bin log 的区别"></a>redo log 和 bin log 的区别</h2><ul><li><strong>日志级别不同</strong>：重做日志是在 InnoDB 存储引擎层产生的，而二进制日志是在 MySQL 数据库的上层的产生的。</li><li><strong>日志内容不同</strong>：二进制日志是一种逻辑日志，记录的是执行的SQL，而重做日志是物理格式日志，其记录的是对每个页的修改。</li><li><strong>写入磁盘时间不同</strong>：二进制日志只在事务提交完成后一次写入，而重做日志在事务执行中不断被写入。</li></ul><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;事务的四个特性是什么？&lt;/li&gt;
&lt;li&gt;Mysql的四种隔离级别以及带来的问题&lt;/li&gt;
&lt;li&gt;MVCC熟悉吗，它的底层原理？&lt;/li&gt;
&lt;li&gt;InnoDB 是如何解决幻读？原理？&lt;/li&gt;
&lt;li&gt;介绍一下InnoDB的日志？&lt;</summary>
      
    
    
    
    <category term="CS-Middleware" scheme="https://blog.haxianhe.com/categories/CS-Middleware/"/>
    
    
    <category term="mysql" scheme="https://blog.haxianhe.com/tags/mysql/"/>
    
    <category term="《破壁MySQL》" scheme="https://blog.haxianhe.com/tags/《破壁MySQL》/"/>
    
  </entry>
  
  <entry>
    <title>破壁MySQL - 索引</title>
    <link href="https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-02/"/>
    <id>https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-02/</id>
    <published>2021-09-24T18:00:02.000Z</published>
    <updated>2021-11-23T12:50:38.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p></blockquote><p>在上一篇文章 <a href="https://haxianhe.com/2021/01/09/CS-Technical-mysql/break-mysql-overview/" target="_blank" rel="noopener">「《破壁MySQL》 - MySQL概述」</a> 中我们简单介绍了MySQL 架构和 MySQL 存储引擎的相关知识，那么在这一篇文章中我们主要介绍的是 <strong>InnoDB存储引擎的索引实现原理</strong>，文章中在每介绍一部分知识点后都会给出<strong>知识点相对应的常见面试题以及答案</strong>，达到理论和实践相结合的效果。</p><blockquote><p><strong>面试题1：说说你对 MySQL 索引的理解？/InnoDB引擎中的索引策略，了解过吗？</strong></p></blockquote><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong>。</p><p><strong>索引的目的在于提高查询效率</strong>，可以类比字典、 火车站的车次表、图书的目录等</p><h2 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树，平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p><strong>B+ Tree 是 B 树的一种变形，它是基于 B Tree 和叶子节点顺序访问指针进行实现，通常用于数据库和操作系统的文件系统中。</strong> </p><p>B+ 树有两种类型的节点：<strong>内部节点</strong>（也称索引节点）和<strong>叶子节点。</strong></p><p>内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存在叶子节点。</p><p>内部节点中的 key 都按照从小到大的顺序排列，对于内部节点中的一个 key，左子树中的所有 key 都小于它，右子树中的 key 都大于等于它，叶子节点的记录也是按照从小到大排列的。</p><p>每个叶子节点都存有相邻叶子节点的指针。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122135258.png" alt></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>查找</strong></p><p>查找以典型的方式进行，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。</p><p><strong>插入</strong></p><ul><li>Perform a search to determine what bucket the new record should go into.</li><li>If the bucket is not full(a most b - 1 entries after the insertion，b 是节点中的元素个数，一般是页的整数倍),add tht record.</li><li><p>Otherwise,before inserting the new record</p><ul><li>split the bucket.<ul><li>original node has 「(L+1)/2」items</li><li>new node has 「(L+1)/2」items</li></ul></li><li>Move  「(L+1)/2」-th key to the parent,and insert the new node to the parent.</li><li>Repeat until a parent is found that need not split.</li></ul></li><li><p>If the root splits,treat it as if it has an empty parent ans split as outline above.</p></li></ul><p>B-trees grow as the root and not at the leaves.</p><p><strong>删除</strong></p><p>和插入类似，只不过是自下而上的合并操作。</p><h3 id="常见树介绍"><a href="#常见树介绍" class="headerlink" title="常见树介绍"></a>常见树介绍</h3><p><strong>AVL 树</strong></p><p>平衡二叉树，一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。所以 AVL 树适用于插入/删除次数比较少，但查找多的场景。</p><p><strong>红黑树</strong></p><p>通过对从根节点到叶子节点路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。适合，查找少，插入/删除次数多的场景。（现在部分场景使用跳表来替换红黑树，可搜索“为啥 redis 使用跳表(skiplist)而不是使用 red-black？”）</p><p><strong>B/B+ 树</strong></p><p>多路查找树，出度高，磁盘IO低，一般用于数据库系统中。</p><blockquote><p><strong>面试题2：B+ 树和 B 树的区别是什么？</strong></p></blockquote><h3 id="B-树与-B-树的比较"><a href="#B-树与-B-树的比较" class="headerlink" title="B + 树与 B 树的比较"></a>B + 树与 B 树的比较</h3><ul><li>B+ 树的内部节点并没有指向关键字具体信息的指针</li><li>B+ 树的叶子节点具有指向左右叶子节点的指针</li></ul><p>B+ 树的磁盘 IO 更低</p><p>B+ 树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对 B 树更小。</p><p>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>B+ 树的范围查询、遍历效率高</p><p>B+ 树的叶子节点具有指向左右叶子节点的指针。因此其范围查询效率更高、遍历效率更高。</p><p>B+ 树的查询效率更加稳定</p><p>由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><h3 id="B-树与红黑树的比较"><a href="#B-树与红黑树的比较" class="headerlink" title="B + 树与红黑树的比较"></a>B + 树与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><p>（一）磁盘 IO 次数</p><p>B+ 树一个节点可以存储多个元素，相对于红黑树的树高更低，磁盘 IO 次数更少。</p><p>（二）磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道。每次会读取页的整数倍。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+ Tree 索引"></a>B+ Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><ul><li><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p></li><li><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p></li><li><p>可以指定多个列作为索引列，多个索引列共同组成键。</p></li><li><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p></li></ul><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122135400.png" alt></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找，这个过程也被称作回表。</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20201122135426.png" alt></p><blockquote><p><strong>面试题3：分页SQL后期查询比较慢是什么原因？怎么处理？</strong></p></blockquote><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">type</span> = <span class="number">1</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure><p>这个没有问题，但是当进入分页后期就有问题了，比如下面这条sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">type</span> = <span class="number">1</span> <span class="keyword">limit</span> <span class="number">100000</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure><p>首先你需要了解B+树的实现原理，当做数据量比较大的分页的时候：</p><ol><li>（根据索引）找到起始位置（叶子结点）</li><li><strong>沿着叶子结点向后遍历，过滤掉前面不在本次返回范围内的数据</strong></li><li>找到目标数据后返回</li></ol><p>从上述过程中可以看到，后期的主要耗时都在沿着叶子结点遍历上边，那么有没有什么方案可以省去这部分耗时呢？</p><p>有的，可以每次遍历结束后记录一下本页id最大值，然后在下一轮查询的时候，在where条件中加上这个id限制，这样可以保证每次查询速度都和第一页保持一致了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">type</span> = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">id</span> &gt; max_id <span class="keyword">limit</span> <span class="number">100000</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>面试题4：什么是覆盖索引？</strong></p></blockquote><p>覆盖索引是要查询的数据列只从索引中就能够取得，不必回表查询主索引树。</p><p>要回答好这个问题，需要你了解上面介绍的B+树的实现原理，理解了原理回答起来就简单了。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li><p>大大减少了服务器需要扫描的数据行数。</p></li><li><p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p></li><li><p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</p></li></ul><h3 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h3><ul><li><p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</p></li><li><p>对于中到大型的表，索引就非常有效；</p></li><li><p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p></li></ul><blockquote><p><strong>为什么对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效？</strong></p></blockquote><p>如果一个表比较小，那么显然直接遍历表比走索引要快（因为需要回表）。</p><p>注：首先，要注意这个答案隐含的条件是查询的数据不是索引的构成部分，否也不需要回表操作。其次，查询条件也不是主键，否则可以直接从聚簇索引中拿到数据。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章是《破壁》系列的第二篇文章，主要介绍了一下索引相关内容。</p><ul><li><a href="https://haxianhe.com/2021/01/09/CS-Technical-mysql/break-mysql-overview/" target="_blank" rel="noopener">《破壁MySQL》 - MySQL概述</a></li><li><a href="https://haxianhe.com/2021/01/30/CS-Technical-mysql/break-mysql-index/" target="_blank" rel="noopener">《破壁MySQL》 - MySQL索引</a></li></ul><p>文中首先从<strong>数据结构</strong>、<strong>操作</strong>、<strong>常见树的比较等</strong>角度介绍了 <strong>B+ 树相关的原理知识</strong>。</p><p>其次着重介绍了一下 <strong>InnoDB 的 B+ 索引的实现原理**</strong>。</p><hr><p>老规矩，文中出现的面试题如下：</p><ul><li>面试题1：说说你对 MySQL 索引的理解？/InnoDB引擎中的索引策略，了解过吗？</li><li>面试题2：B+ 树和 B 树的区别是什么？</li><li>面试题3：分页SQL后期查询比较慢是什么原因？怎么处理？</li><li>面试题4：什么是覆盖索引？</li></ul><p>上面所有面试题都是在文中出现过的，如果如果答不上来可以回到文中再看一下答案以及相应的知识点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://juejin.cn/post/6850037271233331208" target="_blank" rel="noopener">MySQL 三万字精华总结</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#b-tree-%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">CS-Notes-MySQL</a></li></ul><hr><blockquote><p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p></blockquote><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上一篇文章 &lt;a href=&quot;https://haxianhe.com/2021/01/09/CS-Technical-mysql/break</summary>
      
    
    
    
    <category term="CS-Middleware" scheme="https://blog.haxianhe.com/categories/CS-Middleware/"/>
    
    
    <category term="mysql" scheme="https://blog.haxianhe.com/tags/mysql/"/>
    
    <category term="《破壁MySQL》" scheme="https://blog.haxianhe.com/tags/《破壁MySQL》/"/>
    
  </entry>
  
  <entry>
    <title>破壁MySQL - 概述</title>
    <link href="https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-01/"/>
    <id>https://blog.haxianhe.com/2021/09/25/CS-Middleware-Mysql/break-mysql-01/</id>
    <published>2021-09-24T17:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p></blockquote><p>在正式开始总结MySQL之前，先给大家介绍一下“破壁”是什么意思，很久之前我老大曾说过一句 <strong>“互联网本来没有什么行业壁垒，但是通过制造一些专业名词，人为的制造了很多行业壁垒出来”</strong>，我深以为然。  </p><p><strong>计算机的本质是0和1</strong>，之后通过层层封装、抽象构建出了我们今天看到的互联网世界。    </p><p>我不否认计算机中难度很高的知识，但是就我目前接触到的知识来说还没有到那种程度，我想这种可以称之为行业壁垒的核心知识占总知识量的0.01%都不到，绝大多数人一生都不会遇到这些问题。</p><p>那么剩下的就是这一个一个人为制造的、可以通过花时间掌握的“行业壁垒”。</p><p><strong>破壁的意思就是打破这些人为制造的“行业壁垒”</strong>，让我们技术人员人人如龙。</p><hr><p><strong>破壁系列的第一个专题我选择了互联网的数据存储基石 - MySQL。</strong></p><p>这个专题将会总结事务、索引、SQL性能优化、分库分表、主从复制等MySQL核心内容。详情参见下面的思维导图：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210109170855.png" alt></p><h2 id="MySQL-是什么"><a href="#MySQL-是什么" class="headerlink" title="MySQL 是什么"></a>MySQL 是什么</h2><p>MySQL 是一个免费、开源的关系型数据库管理软件，在互联网行业被广泛使用。</p><h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><p>MySQL中插件式存储引擎架构一直是其非常有特色的亮点，其灵活的处理方式，高度可定制化及完全开放的实现一直被很多高级用户所肯定，下图是官方文档中的一张架构图：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210109212031.png" alt></p><ul><li><p>连接层：<strong>这一层主要是提供授权认证、连接处理等功能。</strong> </p><ul><li>在该层上引入了线程池的概念，为通过安全认证的客户端请求提供线程。</li><li>在该层上也可以实现基于SSL的安全链接。</li><li>该层会为通过授权认证的客户端请求分配相应的权限。</li></ul></li><li><p>服务层：这一层实现了很多核心功能，像<strong>查询解析、分析、优化、缓存、以及内置函数</strong>的实现等，所有跨存储引擎的功能也都在这一层实现，像<strong>触发器、存储过程、视图</strong>等。</p></li><li><p>引擎层：存储引擎负责的是MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。MySQL中插件式存储引擎架构的特点，使得我们可以根据自己的实际需要进行存储引擎的选取。</p></li><li><p>存储层：将数据存储在文件系统上。</p></li></ul><p><strong>常见面试题：</strong></p><blockquote><p>MySQL 的查询流程具体是？or 一条 SQL 语句在 MySQL 中如何执行的？<br>介绍一下 MySQL 的架构</p></blockquote><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210109220048.png" alt></p><ol><li>客户发起请求。</li><li>在连接层进行权限校验、线程分配。</li><li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）</li><li>分析器（对SQL进行词法分析和语法分析操作）</li><li>优化器（主要对执行的sql优化选择最优的执行方案方法）</li><li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</li><li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li></ol><h2 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h2><p>MySQL中采用的是插件式存储引擎架构，可以根据需要选择不同的存储引擎。</p><p>现在互联网普遍使用的都是 InnoDB 存储引擎，常见的面试题是 InnoDB 存储引擎和 MyISAM 存储的对比，比如像下面这样问：</p><blockquote><p>Innodb 和 MyISAM 的区别是什么?</p></blockquote><p>可以从如下的角度进行回答：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/image/20210109220751.png" alt></p><ul><li>事务：InnoDB 支持事务，MyISAM 不支持事务</li><li>锁：InnoDB 支持行级锁，MyISAM 只支持表级锁</li><li>外键：InnoDB 支持外键</li><li>InnoDB 支持在线热备份</li><li>MyISAM 支持空间索引</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>MySQL 是现在互联网大小厂主流使用的关系型数据库管理软件，平时工作中也是围绕着它进行开发，所以几乎是面试必考题。</p><p>这篇文章是《破壁》系列，第一个专题的第一篇文章，下面是本系列的其他文章，欢迎阅读～</p><ul><li><a href="https://haxianhe.com/2021/01/09/CS-Technical-mysql/break-mysql-overview/" target="_blank" rel="noopener">《破壁MySQL》 - MySQL概述</a></li><li><a href="https://haxianhe.com/2021/01/30/CS-Technical-mysql/break-mysql-index/" target="_blank" rel="noopener">《破壁MySQL》 - MySQL索引</a></li></ul><p>文章中首先介绍了一下我接下来要写的内容（第一个专题 MySQL），其次是从技术原理和面试题两个角度介绍了 MySQL 架构和 MySQL 存储引擎。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://juejin.cn/post/6850037271233331208" target="_blank" rel="noopener">MySQL 三万字精华总结</a></li></ul><hr><blockquote><p>文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。</p></blockquote><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章每周六持续更新，可以微信搜一搜「 荒古传说 」抢先阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正式开始总结MySQL之前，先给大家介绍一下“破壁”是什么意思，很久之前我老大曾说过一句 &lt;strong&gt;“互联网本来没有什么行业壁垒，但是通</summary>
      
    
    
    
    <category term="CS-Middleware" scheme="https://blog.haxianhe.com/categories/CS-Middleware/"/>
    
    
    <category term="mysql" scheme="https://blog.haxianhe.com/tags/mysql/"/>
    
    <category term="《破壁MySQL》" scheme="https://blog.haxianhe.com/tags/《破壁MySQL》/"/>
    
  </entry>
  
  <entry>
    <title>破壁Java - Maven</title>
    <link href="https://blog.haxianhe.com/2021/09/24/CS-Language-Java/break-java-11/"/>
    <id>https://blog.haxianhe.com/2021/09/24/CS-Language-Java/break-java-11/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.764Z</updated>
    
    <content type="html"><![CDATA[<p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p><h1 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h1><p>在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到commons logging，我们就必须把commons logging的jar包放入classpath。如果我们还需要log4j，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。</p><p>其次，我们要确定项目的目录结构。例如，src目录存放Java源码，resources目录存放配置文件，bin目录存放编译生成的.class文件。</p><p>此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。</p><p>最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。</p><p>这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。</p><p>Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：</p><ul><li>提供了一套标准化的项目结构；</li><li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li><li>提供了一套依赖管理机制。</li></ul><h2 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h2><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><p>项目的根目录a-maven-project是项目名，它有一个项目描述文件pom.xml，存放Java源码的目录是src/main/java，存放资源文件的目录是src/main/resources，存放测试源码的目录是src/test/java，存放测试资源的目录是src/test/resources，最后，所有编译、打包生成的文件都放在target目录里。这些就是一个Maven项目的标准目录结构。</p><p>所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。</p><p>我们再来看最关键的一个项目描述文件pom.xml，它的内容长得像下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hello&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">        ...</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个Maven工程就是由groupId，artifactId和version作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖commons-logging：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用<dependency>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</dependency></p><p><strong>Maven是一个Java项目的管理和构建工具：</strong></p><ul><li>Maven使用pom.xml定义项目内容，并使用预设的目录结构；</li><li>在Maven中声明一个依赖项可以自动下载并导入classpath；</li><li>Maven使用groupId，artifactId和version唯一定位一个依赖。</li></ul><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>如果我们的项目依赖第三方的jar包，例如commons logging，那么问题来了：commons logging发布的jar包在哪下载？</p><p>如果我们还希望依赖log4j，那么使用log4j需要哪些jar包？</p><p>类似的依赖还包括：JUnit，JavaMail，MySQL驱动等等，一个可行的方法是通过搜索引擎搜索到项目的官网，然后手动下载zip包，解压，放入classpath。但是，这个过程非常繁琐。</p><p>Maven解决了依赖管理问题。例如，我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210923112604.png" alt></p><p>当我们声明了abc的依赖时，Maven自动把abc和xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖xyz。</p><p>因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要abc，Maven会自动导入abc的jar包，再判断出abc需要xyz，又会自动导入xyz的jar包，这样，最终我们的项目会依赖abc和xyz两个jar包。</p><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>Maven定义了几种依赖关系，分别是compile、test、runtime和provided：</p><table><thead><tr><th>scope</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>compile</td><td>编译时需要用到该jar包（默认）</td><td>commons-logging</td></tr><tr><td>test</td><td>编译Test时需要用到该jar包</td><td>junit</td></tr><tr><td>runtime</td><td>编译时不需要，但运行时需要用到</td><td>mysql</td></tr><tr><td>provided</td><td>编译时需要用到，但运行时由JDK或某个服务器提供</td><td>servlet-api</td></tr></tbody></table><p>最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（repo1.maven.org），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。</p><p>Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p><h2 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h2><p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p><ul><li>groupId：属于组织的名称，类似Java的包名；</li><li>artifactId：该jar包自身的名称，类似Java的类名；</li><li>version：该jar包的版本。</li></ul><p>通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。</p><p>因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</p><p>注：只有以-SNAPSHOT结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。</p><h2 id="Maven镜像"><a href="#Maven镜像" class="headerlink" title="Maven镜像"></a>Maven镜像</h2><p>除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210924204734.png" alt></p><p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入.m2目录，创建一个settings.xml配置文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;mirrors&gt;</span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;aliyun&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;aliyun&lt;/name&gt;</span><br><span class="line">            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">            &lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span><br><span class="line">            &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;</span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line">    &lt;/mirrors&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>配置镜像仓库后，Maven的下载速度就会非常快。</p><h2 id="搜索第三方组件"><a href="#搜索第三方组件" class="headerlink" title="搜索第三方组件"></a>搜索第三方组件</h2><p>最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过search.maven.org搜索关键字，找到对应的组件后，直接复制：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210924204834.png" alt></p><h2 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h2><p>在命令中，进入到pom.xml所在目录，输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mvn clean package</span><br></pre></td></tr></table></figure><h1 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h1><p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p><h2 id="Lifecycle和Phase"><a href="#Lifecycle和Phase" class="headerlink" title="Lifecycle和Phase"></a>Lifecycle和Phase</h2><p>使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。</p><p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase：</p><ul><li>validate</li><li>initialize</li><li>generate-sources</li><li>process-sources</li><li>generate-resources</li><li>process-resources</li><li>compile</li><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources</li><li>generate-test-resources</li><li>process-test-resources</li><li>test-compile</li><li>process-test-classes</li><li>test</li><li>prepare-package</li><li>package</li><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verify</li><li>install</li><li>deploy</li></ul><p>如果我们运行mvn package，Maven就会执行default生命周期，它会从开始一直运行到package这个phase为止：</p><ul><li>validate</li><li>…</li><li>package</li></ul><p>如果我们运行mvn compile，Maven也会执行default生命周期，但这次它只会运行到compile，即以下几个phase：</p><ul><li>validate</li><li>…</li><li>compile</li></ul><p>Maven另一个常用的生命周期是clean，它会执行3个phase：</p><ul><li>pre-clean</li><li>clean （注意这个clean不是lifecycle而是phase）</li><li>post-clean</li></ul><p>所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。</p><p>更复杂的例子是指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下：</p><ul><li>pre-clean</li><li>clean （注意这个clean是phase）</li><li>validate</li><li>…</li><li>package</li></ul><p>在实际开发过程中，经常使用的命令有：</p><ul><li>mvn clean：清理所有生成的class和jar；</li><li>mvn clean compile：先清理，再执行到compile；</li><li>mvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile；</li><li>mvn clean package：先清理，再执行到package。</li></ul><p>大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。</p><p>经常用到的phase其实只有几个：</p><ul><li>clean：清理</li><li>compile：编译</li><li>test：运行测试</li><li>package：打包</li></ul><p><strong>Goal</strong></p><p>执行一个phase又会触发一个或多个goal：</p><table><thead><tr><th>执行的Phase</th><th>对应执行的Goal</th></tr></thead><tbody><tr><td>compile</td><td>compiler:compile</td></tr><tr><td>test</td><td>compiler:testCompile</td></tr></tbody></table><p>surefire:test |</p><p>goal的命名总是abc:xyz这种形式。</p><p>看到这里，相信大家对lifecycle、phase和goal已经明白了吧？</p><p>其实我们类比一下就明白了：</p><ul><li>lifecycle相当于Java的package，它包含一个或多个phase；</li><li>phase相当于Java的class，它包含一个或多个goal；</li><li>goal相当于class的method，它其实才是真正干活的。</li></ul><p>大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn tomcat:run</span><br></pre></td></tr></table></figure><p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p><p>最常用的构建命令是指定phase，然后让Maven执行到指定的phase：</p><ul><li>mvn clean</li><li>mvn clean compile</li><li>mvn clean test</li><li>mvn clean package</li></ul><p>通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。</p><h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><p>在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210924205819.png" alt></p><p>对于Maven工程来说，原来是一个大项目：</p><p>single-project<br>├── pom.xml<br>└── src</p><p>现在可以分拆成3个模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mutiple-project</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure><p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;module-a&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;module-a&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.28&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.5.2&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>模块B的pom.xml：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;module-b&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;module-b&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.28&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.5.2&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;parent&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.28&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.5.2&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>注意到parent的<packaging>是pom而不是jar，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：</packaging></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">multiple-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── parent</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── module-a</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── module-b</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">└── module-c</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure><p>这样模块A就可以简化为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">        &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;module-a&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;module-a&lt;/name&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。</p><p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;module-b&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>后，在编译的时候，需要在根目录创建一个pom.xml统一编译：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;build&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;build&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;parent&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;module-a&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;module-b&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;module-c&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个<module>，一次性全部编译。</module></p><p><strong>中央仓库</strong></p><p>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p><p><strong>私有仓库</strong></p><p>私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。</p><p><strong>本地仓库</strong></p><p>本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。</p><h1 id="发布Artifact"><a href="#发布Artifact" class="headerlink" title="发布Artifact"></a>发布Artifact</h1><p>当我们使用commons-logging这些第三方开源库的时候，我们实际上是通过Maven自动下载它的jar包，并根据其pom.xml解析依赖，自动把相关依赖包都下载后加入到classpath。</p><p>那么问题来了：当我们自己写了一个牛逼的开源库时，非常希望别人也能使用，总不能直接放个jar包的链接让别人下载吧？</p><p>如果我们把自己的开源库放到Maven的repo中，那么，别人只需按标准引用groupId:artifactId:version，即可自动下载jar包以及相关依赖。因此，本节我们介绍如何发布一个库到Maven的repo中。</p><p>把自己的库发布到Maven的repo中有好几种方法，我们介绍3种最常用的方法。</p><h2 id="以静态文件发布"><a href="#以静态文件发布" class="headerlink" title="以静态文件发布"></a>以静态文件发布</h2><p>如果我们观察一个中央仓库的Artifact结构，例如Commons Math，它的groupId是org.apache.commons，artifactId是commons-math3，以版本3.6.1为例，发布在中央仓库的文件夹路径就是<a href="https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/，在此文件夹下，commons-math3-3.6.1.jar就是发布的jar包，commons-math3-3.6.1.pom就是它的pom.xml描述文件，commons-math3-3.6.1-sources.jar是源代码，commons-math3-3.6.1-javadoc.jar是文档。其它以.asc、.md5、.sha1结尾的文件分别是GPG签名、MD5摘要和SHA-1摘要。" target="_blank" rel="noopener">https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/，在此文件夹下，commons-math3-3.6.1.jar就是发布的jar包，commons-math3-3.6.1.pom就是它的pom.xml描述文件，commons-math3-3.6.1-sources.jar是源代码，commons-math3-3.6.1-javadoc.jar是文档。其它以.asc、.md5、.sha1结尾的文件分别是GPG签名、MD5摘要和SHA-1摘要。</a></p><p>我们只要按照这种目录结构组织文件，它就是一个有效的Maven仓库。</p><p>我们以广受好评的开源项目how-to-become-rich为例，先创建Maven工程目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">how-to-become-rich</span><br><span class="line">├── maven-repo        &lt;-- Maven本地文件仓库</span><br><span class="line">├── pom.xml           &lt;-- 项目文件</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java      &lt;-- 源码目录</span><br><span class="line">│   │   └── resources &lt;-- 资源目录</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java      &lt;-- 测试源码目录</span><br><span class="line">│       └── resources &lt;-- 测试资源目录</span><br><span class="line">└── target            &lt;-- 编译输出目录</span><br></pre></td></tr></table></figure><p>在pom.xml中添加如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;distributionManagement&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;local-repo-release&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;GitHub Release&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;file:<span class="comment">//$&#123;project.basedir&#125;/maven-repo&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/distributionManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-sources&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-javadocs&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>注意到<distributionmanagement>，它指示了发布的软件包的位置，这里的<url>是项目根目录下的maven-repo目录，在<build>中定义的两个插件maven-source-plugin和maven-javadoc-plugin分别用来创建源码和javadoc，如果不想发布源码，可以把对应的插件去掉。</build></url></distributionmanagement></p><p>我们直接在项目根目录下运行Maven命令mvn clean package deploy，如果一切顺利，我们就可以在maven-repo目录下找到部署后的所有文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">maven-repo</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        └── rich</span><br><span class="line">            └── how-to-become-rich</span><br><span class="line">                ├── 1.0.0</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-javadoc.jar</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-javadoc.jar.md5</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-javadoc.jar.sha1</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-sources.jar</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-sources.jar.md5</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0-sources.jar.sha1</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.jar</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.jar.md5</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.jar.sha1</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.pom</span><br><span class="line">                │   ├── how-to-become-rich-1.0.0.pom.md5</span><br><span class="line">                │   └── how-to-become-rich-1.0.0.pom.sha1</span><br><span class="line">                ├── maven-metadata.xml</span><br><span class="line">                ├── maven-metadata.xml.md5</span><br><span class="line">                └── maven-metadata.xml.sha1</span><br></pre></td></tr></table></figure><p>最后一步，是把这个工程推到GitHub上，并选择Settings-GitHub Pages，选择master branch启用Pages服务：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210924210309.png" alt></p><p>这样，把全部内容推送至GitHub后，即可作为静态网站访问Maven的repo，它的地址是<a href="https://michaelliao.github.io/how-to-become-rich/maven-repo/。版本1.0.0对应的jar包地址是：" target="_blank" rel="noopener">https://michaelliao.github.io/how-to-become-rich/maven-repo/。版本1.0.0对应的jar包地址是：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//michaelliao.github.io/how-to-become-rich/maven-repo/com/itranswarp/rich/how-to-become-rich/1.0.0/how-to-become-rich-1.0.0.jar</span></span><br></pre></td></tr></table></figure><p>现在，如果其他人希望引用这个Maven包，我们可以告知如下依赖即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.itranswarp.rich&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;how-to-become-rich&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>但是，除了正常导入依赖外，对方还需要再添加一个<repository>的声明，即使用方完整的pom.xml如下：</repository></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;how-to-become-rich-usage&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;github-rich-repo&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;The Maven Repository on Github&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//michaelliao.github.io/how-to-become-rich/maven-repo/&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itranswarp.rich&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;how-to-become-rich&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>在<repository>中，我们必须声明发布的Maven的repo地址，其中<id>和<name>可以任意填写，<url>填入GitHub Pages提供的地址+/maven-repo/后缀。现在，即可正常引用这个库并编写代码如下</url></name></id></repository></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Millionaire millionaire = <span class="keyword">new</span> Millionaire();</span><br><span class="line">System.out.println(millionaire.howToBecomeRich());</span><br></pre></td></tr></table></figure><p>有的童鞋会问，为什么使用commons-logging等第三方库时，并不需要声明repo地址？这是因为这些库都是发布到Maven中央仓库的，发布到中央仓库后，不需要告诉Maven仓库地址，因为它知道中央仓库的地址默认是<a href="https://repo1.maven.org/maven2/，也可以通过~/.m2/settings.xml指定一个代理仓库地址以替代中央仓库来提高速度（参考依赖管理的Maven镜像）。" target="_blank" rel="noopener">https://repo1.maven.org/maven2/，也可以通过~/.m2/settings.xml指定一个代理仓库地址以替代中央仓库来提高速度（参考依赖管理的Maven镜像）。</a></p><p>因为GitHub Pages并不会把我们发布的Maven包同步到中央仓库，所以自然使用方必须手动添加一个我们提供的仓库地址。</p><p>此外，通过GitHub Pages发布Maven repo时需要注意一点，即不要改动已发布的版本。因为Maven的仓库是不允许修改任何版本的，对一个库进行修改的唯一方法是发布一个新版本。但是通过静态文件的方式发布repo，实际上我们是可以修改jar文件的，但最好遵守规范，不要修改已发布版本。</p><h2 id="通过Nexus发布到中央仓库"><a href="#通过Nexus发布到中央仓库" class="headerlink" title="通过Nexus发布到中央仓库"></a>通过Nexus发布到中央仓库</h2><p>有的童鞋会问，能不能把自己的开源库发布到Maven的中央仓库，这样用户就不需要声明repo地址，可以直接引用，显得更专业。</p><p>当然可以，但我们不能直接发布到Maven中央仓库，而是通过曲线救国的方式，发布到central.sonatype.org，它会定期自动同步到Maven的中央仓库。Nexus是一个支持Maven仓库的软件，由Sonatype开发，有免费版和专业版两个版本，很多大公司内部都使用Nexus作为自己的私有Maven仓库，而这个central.sonatype.org相当于面向开源的一个Nexus公共服务。</p><p>所以，第一步是在central.sonatype.org上注册一个账号，注册链接非常隐蔽，可以自己先找找，找半小时没找到点这里查看攻略。</p><p>如果注册顺利并审核通过，会得到一个登录账号，然后，通过这个页面一步一步操作就可以成功地将自己的Artifact发布到Nexus上，再耐心等待几个小时后，你的Artifact就会出现在Maven的中央仓库中。</p><p>这里简单提一下发布重点与难点：</p><ul><li>必须正确创建GPG签名，Linux和Mac下推荐使用gnupg2；</li><li>必须在~/.m2/settings.xml中配置好登录用户名和口令，以及GPG口令：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;servers&gt;</span><br><span class="line">        &lt;server&gt;</span><br><span class="line">            &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">            &lt;username&gt;OSSRH-USERNAME&lt;/username&gt;</span><br><span class="line">            &lt;password&gt;OSSRH-PASSWORD&lt;/password&gt;</span><br><span class="line">        &lt;/server&gt;</span><br><span class="line">    &lt;/servers&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;gpg.executable&gt;gpg2&lt;/gpg.executable&gt;</span><br><span class="line">                &lt;gpg.passphrase&gt;GPG-PASSWORD&lt;/gpg.passphrase&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>在待发布的Artifact的pom.xml中添加OSS的Maven repo地址，以及maven-jar-plugin、maven-source-plugin、maven-javadoc-plugin、maven-gpg-plugin、nexus-staging-maven-plugin：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;distributionManagement&gt;</span><br><span class="line">        &lt;snapshotRepository&gt;</span><br><span class="line">            &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;</span></span><br><span class="line">        &lt;/snapshotRepository&gt;</span><br><span class="line"></span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;ossrh&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Nexus Release Repository&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http:<span class="comment">//oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/distributionManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                            &lt;goal&gt;test-jar&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-sources&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-javadocs&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;additionalOption&gt;</span><br><span class="line">                                &lt;additionalOption&gt;-Xdoclint:none&lt;/additionalOption&gt;</span><br><span class="line">                            &lt;/additionalOption&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;sign-artifacts&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;verify&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;sign&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.6.3&lt;/version&gt;</span><br><span class="line">                &lt;extensions&gt;true&lt;/extensions&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;serverId&gt;ossrh&lt;/serverId&gt;</span><br><span class="line">                    &lt;nexusUrl&gt;https:<span class="comment">//oss.sonatype.org/&lt;/nexusUrl&gt;</span></span><br><span class="line">                    &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>最后执行命令mvn clean package deploy即可发布至central.sonatype.org。</p><p>此方法前期需要复杂的申请账号和项目的流程，后期需要安装调试GPG，但只要跑通流程，后续发布都只需要一行命令。</p><h2 id="发布到私有仓库"><a href="#发布到私有仓库" class="headerlink" title="发布到私有仓库"></a>发布到私有仓库</h2><p>通过nexus-staging-maven-plugin除了可以发布到central.sonatype.org外，也可以发布到私有仓库，例如，公司内部自己搭建的Nexus服务器。</p><p>如果没有私有Nexus服务器，还可以发布到GitHub Packages。GitHub Packages是GitHub提供的仓库服务，支持Maven、NPM、Docker等。使用GitHub Packages时，无论是发布Artifact，还是引用已发布的Artifact，都需要明确的授权Token，因此，GitHub Packages只能作为私有仓库使用。</p><p>在发布前，我们必须首先登录后在用户的Settings-Developer settings-Personal access tokens中创建两个Token，一个用于发布，一个用于使用。发布Artifact的Token必须有repo、write:packages和read:packages权限：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210924210604.png" alt></p><p>使用Artifact的Token只需要read:packages权限。</p><p>在发布端，把GitHub的用户名和发布Token写入~/.m2/settings.xml配置中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;servers&gt;</span><br><span class="line">        &lt;server&gt;</span><br><span class="line">            &lt;id&gt;github-release&lt;/id&gt;</span><br><span class="line">            &lt;username&gt;GITHUB-USERNAME&lt;/username&gt;</span><br><span class="line">            &lt;password&gt;f052...c21f&lt;/password&gt;</span><br><span class="line">        &lt;/server&gt;</span><br><span class="line">    &lt;/servers&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>然后，在需要发布的Artifact的pom.xml中，添加一个<repository>声明：</repository></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;distributionManagement&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;github-release&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;GitHub Release&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//maven.pkg.github.com/michaelliao/complex&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/distributionManagement&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>注意到<id>和~/.m2/settings.xml配置中的<id>要保持一致，因为发布时Maven根据id找到用于登录的用户名和Token，才能成功上传文件到GitHub。我们直接通过命令mvn clean package deploy部署，成功后，在GitHub用户页面可以看到该Artifact：</id></id></p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210924210649.png" alt></p><p>完整的配置请参考complex项目，这是一个非常简单的支持复数运算的库。</p><p>使用该Artifact时，因为GitHub的Package只能作为私有仓库使用，所以除了在使用方的pom.xml中声明<repository>外：</repository></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;project ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;github-release&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;GitHub Release&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//maven.pkg.github.com/michaelliao/complex&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.itranswarp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;complex&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>还需要把有读权限的Token配置到~/.m2/settings.xml文件中。</p><p>使用Maven发布一个Artifact时：</p><ul><li>可以发布到本地，然后推送到远程Git库，由静态服务器提供基于网页的repo服务，使用方必须声明repo地址；</li><li>可以发布到central.sonatype.org，并自动同步到Maven中央仓库，需要前期申请账号以及本地配置；</li><li>可以发布到GitHub Packages作为私有仓库使用，必须提供Token以及正确的权限才能发布和使用。</li></ul><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。&lt;/p&gt;
&lt;h1 id=&quot;Maven介绍&quot;&gt;&lt;a href=&quot;#Maven介绍&quot; class=&quot;headerlink&quot; title=&quot;Ma</summary>
      
    
    
    
    <category term="CS-Language" scheme="https://blog.haxianhe.com/categories/CS-Language/"/>
    
    
    <category term="java" scheme="https://blog.haxianhe.com/tags/java/"/>
    
    <category term="《破壁 Java》" scheme="https://blog.haxianhe.com/tags/《破壁-Java》/"/>
    
  </entry>
  
  <entry>
    <title>一个死锁的case</title>
    <link href="https://blog.haxianhe.com/2021/09/16/CS-Middleware-Mysql/%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84case/"/>
    <id>https://blog.haxianhe.com/2021/09/16/CS-Middleware-Mysql/%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84case/</id>
    <published>2021-09-16T04:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>今天线上流水的consumer出现了一个insert导致的死锁问题，这里通过一个DEMO复现一下case的整个过程，并进行详细的分析。</p><p>表结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table test_table;</span><br><span class="line">| Table      | Create Table                                                                                </span><br><span class="line">| test_table | CREATE TABLE `test_table` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a` int NOT NULL,</span><br><span class="line">  `b` int DEFAULT &apos;0&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `test_table_a_uindex` (`a`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>表数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_table;</span><br><span class="line">+----+----+------+</span><br><span class="line">| id | a  | b    |</span><br><span class="line">+----+----+------+</span><br><span class="line">|  1 |  1 |    1 |</span><br><span class="line">| 20 | 20 |   20 |</span><br><span class="line">| 50 | 50 |   50 |</span><br><span class="line">+----+----+------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><p><strong>事务中的代码是先update，如果记录不存在再去insert。</strong></p><p>事务1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update test_table set b = 1 where a = 30;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>事务1开启事务，并update一条不存在的记录（此时会对a，[20,50]加间隙锁）。</p><p>事务2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update test_table set b = 1 where a = 31;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>事务2开启事务，并update一条不存在的记录（此时同样会对a，[20,50加间隙锁]）。</p><p>事务1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_table values(30,30,1);</span><br><span class="line">mysql&gt; waiting...</span><br></pre></td></tr></table></figure><p>事务1插入一条记录，此时会被阻塞…</p><p>事务2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ysql&gt; insert into test_table values(31,31,1);</span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure><p>事务2同样插入一条记录，此时会报错，死锁，并回滚事务。</p><p>事务1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_table values(30,30,1);</span><br><span class="line">Query OK, 1 row affected (12.58 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>事务2回滚后，事务1插入成功，事务提交成功。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>1.事务1、事务2中分别进行了一次update操作，并且操作的记录都不存在，此时，事务1、2分别会对a，[20,50]范围加一个间隙锁。</p><p>注：间隙锁与间隙锁之间可以兼容（共享锁）</p><p>2.事务1中进行了一次insert操作，此时由于事务2对a，[20,50]范围加了一个间隙锁，所以事务1的insert操作处于阻塞状态。</p><p>3.事务2中也进行了一次insert操作，同样被事务1的间隙锁阻塞。<strong>此时事务1在等事务2释放间隙锁，而事务2也在等事务1释放间隙锁，构成死锁，所以事务2报错“死锁”并进行事务回滚。</strong></p><p>4.事务2回滚后，事务2的间隙锁被释放，事务1的insert操作执行成功，事务1提交成功。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>考虑了两种解决方案：</p><p><strong>方案一</strong></p><p>将事务中的插入操作提到事务之前执行，每次事务开始前先select一下，如果记录不存在插入一条空记录进去，在事务中只需要执行update操作。</p><p>缺点：多进行了一次select操作，可能对接口性能造成影响，需要重新进行压测判断。</p><p><strong>方案二</strong></p><p>降低mysql事务隔离级别，从RR下调到RC。</p><p>缺点：存在幻读问题</p><p>综合考虑，由于这个集群只用于流水和统计数据的存储，所以采用了 <strong>方案二：调低事务隔离级别</strong>。</p><h1 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h1><p><strong>InnoDB中RR隔离级别是否存在幻读问题？</strong></p><p>回答这个问题前，我先假设你知道<strong>数据库隔离级别的定义针对的都是“当前读”</strong>。</p><p>首先我们来看一段InnoDB官方文档的话：</p><blockquote><p>For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE), UPDATE, and DELETE statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition. For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it. For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key locks to block insertions by other sessions into the gaps covered by the range.</p></blockquote><p>大致意思就是，在 RR 级别下，如果查询条件能使用上唯一索引，或者是一个唯一的查询条件，那么仅加行锁，如果是一个范围查询，那么就会给这个范围加上 gap 锁或者 next-key锁 (行锁+gap锁)。</p><p>InnoDB 的 RR 隔离界别对范围会加上 GAP，不会存在幻读。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>事务最好不要太长，否则容易出现锁等待、死锁等问题</li><li>insert操作最好不要放到事务里，否则容易引发死锁问题（相互等待）。</li></ul><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;今天线上流水的consumer出现了一个insert导致的死锁问题，这里通过一个DEMO复现一下case的整个过程，并进行详</summary>
      
    
    
    
    <category term="CS-Middleware" scheme="https://blog.haxianhe.com/categories/CS-Middleware/"/>
    
    
    <category term="mysql" scheme="https://blog.haxianhe.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>破壁Java - 函数式编程</title>
    <link href="https://blog.haxianhe.com/2021/09/16/CS-Language-Java/break-java-10/"/>
    <id>https://blog.haxianhe.com/2021/09/16/CS-Language-Java/break-java-10/</id>
    <published>2021-09-15T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.763Z</updated>
    
    <content type="html"><![CDATA[<p>函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。</p><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>观察Lambda表达式的写法，它只需要写出方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(s1, s2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，参数是(s1, s2)，参数类型可以省略，因为编译器可以自动推断出String类型。-&gt; { … }表示方法体，所有代码写在内部即可。Lambda表达式没有class定义，因此写法非常简洁。</p><p>如果只有一行return xxx的代码，完全可以用更简单的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure><p>返回值的类型也是由编译器自动推断的，这里推断出的返回值是int，因此，只要返回int，编译器就不会报错。</p><p><strong>FunctionalInterface</strong></p><p>我们把只定义了单方法的接口称之为FunctionalInterface，用注解@FunctionalInterface标记。例如，Callable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看Comparator接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Comparator接口有很多方法，但只有一个抽象方法int compare(T o1, T o2)，其他的方法都是default方法或static方法。另外注意到boolean equals(Object obj)是Object定义的方法，不算在接口方法内。因此，Comparator也是一个FunctionalInterface。</p><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。</p><p>注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系。</p><p>FunctionalInterface允许传入：</p><ul><li>接口的实现类（传统写法，代码较繁琐）；</li><li>Lambda表达式（只需列出参数名，由编译器推断类型）；</li><li>符合方法签名的静态方法；</li><li>符合方法签名的实例方法（实例类型被看做第一个参数类型）；</li><li>符合方法签名的构造方法（实例类型被看做返回类型）。</li></ul><p>FunctionalInterface不强制继承关系，不需要方法名称相同，只要求方法参数（类型和数量）与方法返回类型相同，即认为方法签名相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用构造方法</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">"Bob"</span>, <span class="string">"Alice"</span>, <span class="string">"Tim"</span>);</span><br><span class="line">        List&lt;Person&gt; persons = names.stream().map(Person::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person:"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream-概述"><a href="#Stream-概述" class="headerlink" title="Stream 概述"></a>Stream 概述</h1><p>Java从8开始，不但引入了Lambda表达式，还引入了一个全新的流式API：Stream API。它位于java.util.stream包中。</p><p>划重点：这个Stream不同于java.io的InputStream和OutputStream，它代表的是任意Java对象的序列。两者对比如下：</p><table><thead><tr><th></th><th>java.io</th><th>java.util.stream</th></tr></thead><tbody><tr><td>存储</td><td>顺序读写的byte或char</td><td>顺序输出的任意Java对象实例</td></tr><tr><td>用途</td><td>序列化至文件或网络</td><td>内存计算／业务逻辑</td></tr></tbody></table><p>有同学会问：一个顺序输出的Java对象序列，不就是一个List容器吗？</p><p>再次划重点：这个Stream和List也不一样，List存储的每个元素都是已经存储在内存中的某个Java对象，而Stream输出的元素可能并没有预先存储在内存中，而是实时计算出来的。</p><p>换句话说，List的用途是操作一组已存在的Java对象，而Stream实现的是惰性计算，两者对比如下：</p><table><thead><tr><th></th><th>java.util.List</th><th>java.util.stream</th></tr></thead><tbody><tr><td>元素</td><td>已分配并存储在内存</td><td>可能未分配，实时计算</td></tr><tr><td>用途</td><td>操作一组已存在的Java对象</td><td>惰性计算</td></tr></tbody></table><p>Stream的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p><p>Stream的另一个特点是，一个Stream可以轻易地转换为另一个Stream，而不是修改原Stream本身。</p><p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p><p>惰性计算的特点是：一个Stream转换为另一个Stream时，实际上只存储了转换规则，并没有任何计算发生。</p><p>例如，创建一个全体自然数的Stream，不会进行计算，把它转换为上述s2这个Stream，也不会进行计算。再把s2这个无限Stream转换为s3这个有限的Stream，也不会进行计算。只有最后，调用forEach确实需要Stream输出的元素时，才进行计算。我们通常把Stream的操作写成链式操作，代码更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createNaturalStream()</span><br><span class="line">    .map(BigInteger::multiply)</span><br><span class="line">    .limit(<span class="number">100</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>因此，Stream API的基本用法就是：创建一个Stream，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = createNaturalStream() <span class="comment">// 创建Stream</span></span><br><span class="line">             .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .map(n -&gt; n * n) <span class="comment">// 任意个转换</span></span><br><span class="line">             .limit(<span class="number">100</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .sum(); <span class="comment">// 最终计算结果</span></span><br></pre></td></tr></table></figure><p>Stream API的特点是：</p><ul><li>Stream API提供了一套新的流式处理的抽象序列；</li><li>Stream API支持函数式编程和链式操作；</li><li>Stream可以表示无限序列，并且大多数情况下是惰性求值的。</li></ul><h1 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h1><p>要使用Stream，就必须先创建它。创建Stream有很多种方法，我们来一一介绍。</p><p><strong>Stream.of()</strong></p><p>创建Stream最简单的方式是直接用Stream.of()静态方法，传入可变参数即创建了一个能输出确定元素的Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>);</span><br><span class="line">        <span class="comment">// forEach()方法相当于内部循环调用，</span></span><br><span class="line">        <span class="comment">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便。</p><p><strong>基于数组或Collection</strong></p><p>第二种创建Stream的方法是基于一个数组或者Collection，这样该Stream输出的元素就是数组或者Collection持有的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(<span class="keyword">new</span> String[] &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span> &#125;);</span><br><span class="line">        Stream&lt;String&gt; stream2 = List.of(<span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>).stream();</span><br><span class="line">        stream1.forEach(System.out::println);</span><br><span class="line">        stream2.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把数组变成Stream使用Arrays.stream()方法。对于Collection（List、Set、Queue等），直接调用stream()方法就可以获得Stream。</p><p>上述创建Stream的方法都是把一个现有的序列变为Stream，它的元素是固定的。</p><p><strong>基于Supplier</strong></p><p>创建Stream还可以通过Stream.generate()方法，它需要传入一个Supplier对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure><p>基于Supplier创建的Stream会不断调用Supplier.get()方法来不断产生下一个元素，这种Stream保存的不是元素，而是算法，它可以用来表示无限序列。</p><p>例如，我们编写一个能不断生成自然数的Supplier，它的代码非常简单，每次调用get()方法，就生成下一个自然数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; natual = Stream.generate(<span class="keyword">new</span> NatualSupplier());</span><br><span class="line">        <span class="comment">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class="line">        natual.limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NatualSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们用一个Supplier<integer>模拟了一个无限序列（当然受int范围限制不是真的无限大）。如果用List表示，即便在int范围内，也会占用巨大的内存，而Stream几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</integer></p><p>对于无限序列，如果直接调用forEach()或者count()这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用limit()方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用forEach()或者count()操作就没有问题。</p><p><strong>基本类型</strong></p><p>因为Java的范型不支持基本类型，所以我们无法用Stream<int>这样的类型，会发生编译错误。为了保存int，只能使用Stream<integer>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了IntStream、LongStream和DoubleStream这三种使用基本类型的Stream，它们的使用方法和范型Stream没有大的区别，设计这三个Stream的目的是提高运行效率：</integer></int></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将int[]数组变为IntStream:</span></span><br><span class="line">IntStream is = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class="line">LongStream ls = List.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure><h1 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h1><p>Stream.map()是Stream最常用的一个转换方法，它把一个Stream转换为另一个Stream。</p><p>所谓map操作，就是把一种操作运算，映射到一个序列的每一个元素上。例如，对x计算它的平方，可以使用函数f(x) = x * x。我们把这个函数映射到一个序列1，2，3，4，5上，就得到了另一个序列1，4，9，16，25：</p><p>map操作，把一个Stream的每个元素一一对应到应用了目标函数的结果上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</span><br></pre></td></tr></table></figure><p>如果我们查看Stream的源码，会发现map()方法接收的对象是Function接口对象，它定义了一个apply()方法，负责把一个T类型转换成R类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，Function的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 将T类型转换为R:</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用map()，不但能完成数学计算，对于字符串操作，以及任何Java对象都是非常有用的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List.of(<span class="string">"  Apple "</span>, <span class="string">" pear "</span>, <span class="string">" ORANGE"</span>, <span class="string">" BaNaNa "</span>)</span><br><span class="line">                .stream()</span><br><span class="line">                .map(String::trim) <span class="comment">// 去空格</span></span><br><span class="line">                .map(String::toLowerCase) <span class="comment">// 变小写</span></span><br><span class="line">                .forEach(System.out::println); <span class="comment">// 打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过若干步map转换，可以写出逻辑简单、清晰的代码。</p><h1 id="使用filter"><a href="#使用filter" class="headerlink" title="使用filter"></a>使用filter</h1><p>Stream.filter()是Stream的另一个常用转换方法。</p><p>所谓filter()操作，就是对一个Stream的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的Stream。</p><p>filter()方法接收的对象是Predicate接口对象，它定义了一个test()方法，负责判断元素是否符合条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 判断元素t是否符合条件:</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用reduce"><a href="#使用reduce" class="headerlink" title="使用reduce"></a>使用reduce</h1><p>map()和filter()都是Stream的转换方法，而Stream.reduce()则是Stream的一个聚合方法，它可以把一个Stream的所有元素按照聚合函数聚合成一个结果。</p><p>reduce()方法传入的对象是BinaryOperator接口，它定义了一个apply()方法，负责把上次累加的结果和本次的元素 进行运算，并返回累加的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryOperator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Bi操作：两个输入，一个输出</span></span><br><span class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t, T u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出集合"><a href="#输出集合" class="headerlink" title="输出集合"></a>输出集合</h1><p>我们介绍了Stream的几个常见操作：map()、filter()、reduce()。这些操作对Stream来说可以分为两类，一类是转换操作，即把一个Stream转换为另一个Stream，例如map()和filter()，另一类是聚合操作，即对Stream的每个元素进行计算，得到一个确定的结果，例如reduce()。</p><p>区分这两种操作是非常重要的，因为对于Stream来说，对其进行转换操作并不会触发任何计算！</p><p>聚合操作是真正需要从Stream请求数据的，对一个Stream做聚合计算后，结果就不是一个Stream，而是一个其他的Java对象。</p><p><strong>输出为List</strong></p><p>reduce()只是一种聚合操作，如果我们希望把Stream的元素保存到集合，例如List，因为List的元素是确定的Java对象，因此，把Stream变为List不是一个转换操作，而是一个聚合操作，它会强制Stream输出每个元素。</p><p>下面的代码演示了如何将一组String先过滤掉空字符串，然后把非空字符串保存到List中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"Apple"</span>, <span class="string">""</span>, <span class="keyword">null</span>, <span class="string">"Pear"</span>, <span class="string">"  "</span>, <span class="string">"Orange"</span>);</span><br><span class="line">        List&lt;String&gt; list = stream.filter(s -&gt; s != <span class="keyword">null</span> &amp;&amp; !s.isBlank()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把Stream的每个元素收集到List的方法是调用collect()并传入Collectors.toList()对象，它实际上是一个Collector实例，通过类似reduce()的操作，把每个元素添加到一个收集器中（实际上是ArrayList）。</p><p>类似的，collect(Collectors.toSet())可以把Stream的每个元素收集到Set中。</p><p><strong>输出为数组</strong></p><p>把Stream的元素输出为数组和输出为List类似，我们只需要调用toArray()方法，并传入数组的“构造方法”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</span><br><span class="line">String[] array = list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>注意到传入的“构造方法”是String[]::new，它的签名实际上是IntFunction&lt;String[]&gt;定义的String[] apply(int)，即传入int参数，获得String[]数组的返回值。</p><p><strong>输出为Map</strong></p><p>如果我们要把Stream的元素收集到Map中，就稍微麻烦一点。因为对于每个元素，添加到Map时需要key和value，因此，我们要指定两个映射函数，分别把元素映射为key和value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"APPL:Apple"</span>, <span class="string">"MSFT:Microsoft"</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = stream</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        <span class="comment">// 把元素s映射为key:</span></span><br><span class="line">                        s -&gt; s.substring(<span class="number">0</span>, s.indexOf(<span class="string">':'</span>)),</span><br><span class="line">                        <span class="comment">// 把元素s映射为value:</span></span><br><span class="line">                        s -&gt; s.substring(s.indexOf(<span class="string">':'</span>) + <span class="number">1</span>)));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分组输出</strong></p><p>Stream还有一个强大的分组功能，可以按组输出。我们看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Blackberry"</span>, <span class="string">"Coconut"</span>, <span class="string">"Avocado"</span>, <span class="string">"Cherry"</span>, <span class="string">"Apricots"</span>);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>), Collectors.toList()));</span><br><span class="line">        System.out.println(groups);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分组输出使用Collectors.groupingBy()，它需要提供两个函数：一个是分组的key，这里使用s -&gt; s.substring(0, 1)，表示只要首字母相同的String分到一组，第二个是分组的value，这里直接使用Collectors.toList()，表示输出为List，上述代码运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    A=[Apple, Avocado, Apricots],</span><br><span class="line">    B=[Banana, Blackberry],</span><br><span class="line">    C=[Coconut, Cherry]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，结果一共有3组，按”A”，”B”，”C”分组，每一组都是一个List。</p><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><p>我们把Stream提供的操作分为两类：转换操作和聚合操作。除了前面介绍的常用操作外，Stream还提供了一系列非常有用的方法。</p><p><strong>排序</strong></p><p>对Stream的元素进行排序十分简单，只需调用sorted()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"Orange"</span>, <span class="string">"apple"</span>, <span class="string">"Banana"</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法要求Stream的每个元素必须实现Comparable接口。如果要自定义排序，传入指定的Comparator即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"Orange"</span>, <span class="string">"apple"</span>, <span class="string">"Banana"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted(String::compareToIgnoreCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>注意sorted()只是一个转换操作，它会返回一个新的Stream。</p><p><strong>去重</strong></p><p>对一个Stream的元素进行去重，没必要先转换为Set，可以直接用distinct()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"D"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure><p><strong>截取</strong></p><p>截取操作常用于把一个无限的Stream转换成有限的Stream，skip()用于跳过当前Stream的前N个元素，limit()用于截取当前Stream最多前N个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .skip(<span class="number">2</span>) <span class="comment">// 跳过A, B</span></span><br><span class="line">    .limit(<span class="number">3</span>) <span class="comment">// 截取C, D, E</span></span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [C, D, E]</span></span><br></pre></td></tr></table></figure><p>截取操作也是一个转换操作，将返回新的Stream。</p><p><strong>合并</strong></p><p>将两个Stream合并为一个Stream可以使用Stream的静态方法concat()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s1 = List.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).stream();</span><br><span class="line">Stream&lt;String&gt; s2 = List.of(<span class="string">"D"</span>, <span class="string">"E"</span>).stream();</span><br><span class="line"><span class="comment">// 合并:</span></span><br><span class="line">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class="line">System.out.println(s.collect(Collectors.toList())); <span class="comment">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure><p><strong>flatMap</strong></p><p>如果Stream的元素是集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br></pre></td></tr></table></figure><p>而我们希望把上述Stream转换为Stream<integer>，就可以使用flatMap()：</integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure><p>因此，所谓flatMap()，是指把Stream的每个元素（这里是List）映射为Stream，然后合并成一个新的Stream：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210916184519.png" alt></p><p><strong>并行</strong></p><p>通常情况下，对Stream的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理Stream的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p><p>把一个普通Stream转换为可以并行处理的Stream非常简单，只需要用parallel()进行转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">String[] result = s.parallel() <span class="comment">// 变成一个可以并行处理的Stream</span></span><br><span class="line">                   .sorted() <span class="comment">// 可以进行并行排序</span></span><br><span class="line">                   .toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>经过parallel()转换后的Stream只要可能，就会对后续操作进行并行处理。我们不需要编写任何多线程代码就可以享受到并行处理带来的执行效率的提升。</p><p><strong>其他聚合方法</strong></p><p>除了reduce()和collect()外，Stream还有一些常用的聚合方法：</p><ul><li>count()：用于返回元素个数；</li><li>max(Comparator&lt;? super T&gt; cp)：找出最大元素；</li><li>min(Comparator&lt;? super T&gt; cp)：找出最小元素。</li></ul><p>针对IntStream、LongStream和DoubleStream，还额外提供了以下聚合方法：</p><ul><li>sum()：对所有元素求和；</li><li>average()：对所有元素求平均数。</li></ul><p>还有一些方法，用来测试Stream的元素是否满足以下条件：</p><ul><li>boolean allMatch(Predicate&lt;? super T&gt;)：测试是否所有元素均满足测试条件；</li><li>boolean anyMatch(Predicate&lt;? super T&gt;)：测试是否至少有一个元素满足测试条件。</li></ul><p>最后一个常用的方法是forEach()，它可以循环处理Stream的每个元素，我们经常传入System.out::println来打印Stream的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">s.forEach(str -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, "</span> + str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Stream提供的常用操作有：</p><ul><li>转换操作：map()，filter()，sorted()，distinct()； </li><li>合并操作：concat()，flatMap()；</li><li>并行处理：parallel()；</li><li>聚合操作：reduce()，collect()，count()，max()，min()，sum()，average()；</li><li>其他操作：allMatch(), anyMatch(), forEach()。</li></ul><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。&lt;/p&gt;
&lt;h1 id=&quot;Lamb</summary>
      
    
    
    
    <category term="CS-Language" scheme="https://blog.haxianhe.com/categories/CS-Language/"/>
    
    
    <category term="java" scheme="https://blog.haxianhe.com/tags/java/"/>
    
    <category term="《破壁 Java》" scheme="https://blog.haxianhe.com/tags/《破壁-Java》/"/>
    
  </entry>
  
  <entry>
    <title>破壁Java - 单元测试</title>
    <link href="https://blog.haxianhe.com/2021/09/15/CS-Language-Java/break-java-09/"/>
    <id>https://blog.haxianhe.com/2021/09/15/CS-Language-Java/break-java-09/</id>
    <published>2021-09-14T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写JUnit测试"><a href="#编写JUnit测试" class="headerlink" title="编写JUnit测试"></a>编写JUnit测试</h1><p>什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p><p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p><p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210915161431.png" alt></p><p>这就是传说中的……</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210915161452.png" alt></p><p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。</p><p>JUnit</p><p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。</p><p>使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。</p><p>核心测试方法testFact()加上了@Test注解，这是JUnit要求的，它会把带有@Test的方法识别为测试方法。在测试方法内部，我们用assertEquals(1, Factorial.fact(1))表示，期望Factorial.fact(1)返回1。assertEquals(expected, actual)是最常用的测试方法，它在Assertion类中定义。Assertion还定义了其他断言方法，例如：</p><ul><li>assertTrue(): 期待结果为true</li><li>assertFalse(): 期待结果为false</li><li>assertNotNull(): 期待结果为非null</li><li>assertArrayEquals(): 期待结果为数组并与期望数组每个元素的值均相等</li><li>…</li></ul><p><strong>单元测试的好处</strong></p><p>单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p><p>使用JUnit进行单元测试，我们可以使用断言（Assertion）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</p><p>在编写单元测试的时候，我们要遵循一定的规范：</p><p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p><p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p><p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串””等情况。</p><h1 id="使用Fixture"><a href="#使用Fixture" class="headerlink" title="使用Fixture"></a>使用Fixture</h1><p>在一个单元测试中，我们经常编写多个@Test方法，来分组、分类对目标代码进行测试。</p><p>在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个@Test方法都写一遍这样的重复代码，显然比较麻烦。</p><p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p><p>编写Fixture的套路如下：</p><ul><li><p>对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例；</p></li><li><p>对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法。</p></li></ul><p>大多数情况下，使用@BeforeEach和@AfterEach就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到@BeforeAll和@AfterAll。</p><p>最后，注意到每次运行一个@Test方法前，JUnit首先创建一个XxxTest实例，因此，每个@Test方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个@Test方法带到另一个@Test方法。</p><h1 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h1><p>在Java程序中，异常处理是非常重要的。</p><p>我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。</p><p>因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。</p><p>JUnit提供assertThrows()来期望捕获一个指定的异常。第二个参数Executable封装了我们要执行的会产生异常的代码。当我们执行Factorial.fact(-1)时，必定抛出IllegalArgumentException。assertThrows()在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p><p>有些童鞋会觉得编写一个Executable的匿名类太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h1><p>在运行测试的时候，有些时候，我们需要排出某些@Test方法，不要让它运行，这时，我们就可以给它标记一个@Disabled：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBug101</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个测试不会运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我们不直接注释掉@Test，而是要加一个@Disabled？这是因为注释掉@Test，JUnit就不知道这是个测试方法，而加上@Disabled，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tests run: <span class="number">68</span>, Failures: <span class="number">2</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>类似@Disabled这种注解就称为条件测试，JUnit根据不同的条件注解，决定是否运行当前的@Test方法。</p><h1 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h1><p>果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法</p><p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p><p>JUnit提供了一个@ParameterizedTest注解，用来进行参数化测试。</p><p>假设我们想对Math.abs()进行测试，先用一组正数进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource</span>(ints = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用一组负数进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource</span>(ints = &#123; -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">100</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbsNegative</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到参数化测试的注解是@ParameterizedTest，而不是普通的@Test。</p><p>实际的测试场景往往没有这么简单。假设我们自己编写了一个StringUtils.capitalize()方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">capitalize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Character.toUpperCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了：参数如何传入？</p><p>最简单的方法是通过@MethodSource注解，它允许我们编写一个同名的静态方法来提供测试参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title">testCapitalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">"abc"</span>, <span class="string">"Abc"</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">"APPLE"</span>, <span class="string">"Apple"</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">"gooD"</span>, <span class="string">"Good"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很容易理解：静态方法testCapitalize()返回了一组测试参数，每个参数都包含两个String，正好作为测试方法的两个参数传入。</p><blockquote><p>如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便</p></blockquote><p>另一种传入测试参数的方法是使用@CsvSource，它的每一个字符串表示一行，一行包含的若干参数用,分隔，因此，上述测试又可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource</span>(&#123; <span class="string">"abc, Abc"</span>, <span class="string">"APPLE, Apple"</span>, <span class="string">"gooD, Good"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有成百上千的测试输入，那么，直接写@CsvSource就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上@CsvFileSource：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource</span>(resources = &#123; <span class="string">"/test-capitalize.csv"</span> &#125;)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit只在classpath中查找指定的CSV文件，因此，test-capitalize.csv这个文件要放到test目录下，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apple, Apple</span><br><span class="line">HELLO, Hello</span><br><span class="line">JUnit, Junit</span><br><span class="line">reSource, Resource</span><br></pre></td></tr></table></figure><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编写JUnit测试&quot;&gt;&lt;a href=&quot;#编写JUnit测试&quot; class=&quot;headerlink&quot; title=&quot;编写JUnit测试&quot;&gt;&lt;/a&gt;编写JUnit测试&lt;/h1&gt;&lt;p&gt;什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能</summary>
      
    
    
    
    <category term="CS-Language" scheme="https://blog.haxianhe.com/categories/CS-Language/"/>
    
    
    <category term="java" scheme="https://blog.haxianhe.com/tags/java/"/>
    
    <category term="《破壁 Java》" scheme="https://blog.haxianhe.com/tags/《破壁-Java》/"/>
    
  </entry>
  
  <entry>
    <title>破壁Java - IO</title>
    <link href="https://blog.haxianhe.com/2021/09/14/CS-Language-Java/break-java-08/"/>
    <id>https://blog.haxianhe.com/2021/09/14/CS-Language-Java/break-java-08/</id>
    <published>2021-09-13T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.762Z</updated>
    
    <content type="html"><![CDATA[<p>IO是指Input/Output，即输入和输出。以内存为中心：</p><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。</p><p>从Java代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以Java提供的某种数据类型表示，例如，byte[]，String，这样，后续代码才能处理这些数据。</p><p>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output实际上就是把Java表示的数据格式，例如，byte[]，String等输出到某个地方。</p><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p><p><strong>InputStream / OutputStream</strong></p><p>IO流以byte（字节）为最小单位，因此也称为字节流。例如，我们要从磁盘读入一个文件，包含6个字节，就相当于读入了6个字节的数据：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210915155033.png" alt></p><p>这6个字节是按顺序读入的，所以是输入字节流。</p><p>反过来，我们把6个字节从内存写入磁盘文件，就是输出字节流：</p><p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210915160942.png" alt></p><p>在Java中，InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流。</p><p><strong>Reader / Writer</strong></p><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照char来读写显然更方便，这种流称为字符流。</p><p>Java提供了Reader和Writer表示字符流，字符流传输的最小数据单位是char。</p><p>例如，我们把char[]数组Hi你好这4个字符用Writer字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符H和i各占一个字节，中文字符你好各占3个字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x48</span></span><br><span class="line"><span class="number">0x69</span></span><br><span class="line"><span class="number">0xe4bda0</span></span><br><span class="line"><span class="number">0xe5a5bd</span></span><br></pre></td></tr></table></figure><p>反过来，我们用Reader读取以UTF-8编码的这8个字节，会从Reader中得到Hi你好这4个字符。</p><p>因此，Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream。</p><p>使用Reader，数据源虽然是字节，但我们读入的数据都是char类型的字符，原因是Reader内部把读入的byte做了解码，转换成了char。使用InputStream，我们读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。究竟使用Reader还是InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。</p><p><strong>同步和异步</strong></p><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p><p>Java标准库的包java.io提供了同步IO，而java.nio则是异步IO。上面我们讨论的InputStream、OutputStream、Reader和Writer都是同步IO的抽象类，对应的具体实现类，以文件为例，有FileInputStream、FileOutputStream、FileReader和FileWriter。</p><p>本节我们只讨论Java的同步IO，即输入/输出流的IO模型。</p><p><strong>小结</strong></p><p>IO流是一种流式的数据输入/输出模型：</p><ul><li>二进制数据以byte为最小单位在InputStream/OutputStream中单向流动；</li><li>字符数据以char为最小单位在Reader/Writer中单向流动。</li></ul><p>Java标准库的java.io包提供了同步IO功能：</p><ul><li>字节流接口：InputStream/OutputStream；</li><li>字符流接口：Reader/Writer。</li></ul><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IO是指Input/Output，即输入和输出。以内存为中心：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。&lt;/li&gt;
&lt;li&gt;Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据</summary>
      
    
    
    
    <category term="CS-Language" scheme="https://blog.haxianhe.com/categories/CS-Language/"/>
    
    
    <category term="java" scheme="https://blog.haxianhe.com/tags/java/"/>
    
    <category term="《破壁 Java》" scheme="https://blog.haxianhe.com/tags/《破壁-Java》/"/>
    
  </entry>
  
  <entry>
    <title>破壁Java - 集合</title>
    <link href="https://blog.haxianhe.com/2021/09/12/CS-Language-Java/break-java-07/"/>
    <id>https://blog.haxianhe.com/2021/09/12/CS-Language-Java/break-java-07/</id>
    <published>2021-09-11T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.762Z</updated>
    
    <content type="html"><![CDATA[<p>Java标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合：</p><ul><li>List：一种有序列表的集合，例如，按索引排列的Student的List；</li><li>Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set；</li><li>Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。</li></ul><p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 只能放入String类型</span></span><br></pre></td></tr></table></figure><p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li>Hashtable：一种线程安全的Map实现；</li><li>Vector：一种线程安全的List实现；</li><li>Stack：基于Vector实现的LIFO的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li>Enumeration<e>：已被Iterator<e>取代。</e></e></li></ul><p>此外，关于集合具体怎么使用这里不准备展开讲了，用到的时候搜一下就好了。</p><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List：一种有序列表的集合，例如，按索引排列的Student的List</summary>
      
    
    
    
    <category term="CS-Language" scheme="https://blog.haxianhe.com/categories/CS-Language/"/>
    
    
    <category term="java" scheme="https://blog.haxianhe.com/tags/java/"/>
    
    <category term="《破壁 Java》" scheme="https://blog.haxianhe.com/tags/《破壁-Java》/"/>
    
  </entry>
  
  <entry>
    <title>破壁Java - 泛型</title>
    <link href="https://blog.haxianhe.com/2021/09/11/CS-Language-Java/break-java-06/"/>
    <id>https://blog.haxianhe.com/2021/09/11/CS-Language-Java/break-java-06/</id>
    <published>2021-09-10T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.762Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210913105530.png" alt></p><h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><ul><li>泛型就是编写模板代码来适应任意类型；</li><li>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</li><li>注意泛型的继承关系：可以把ArrayList<integer>向上转型为List<integer>（T不能变！），但不能把ArrayList<integer>向上转型为ArrayList<number>（T不能变成父类）。</number></integer></integer></integer></li></ul><p>泛型就是定义一种模板，例如ArrayList<t>，然后在代码中为用到的类创建对应的ArrayList&lt;类型&gt;：</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>由编译器针对类型作检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strList.add(<span class="string">"hello"</span>); <span class="comment">// OK</span></span><br><span class="line">String s = strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line">Integer n = strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><p><strong>向上转型</strong></p><p>在Java标准库中的ArrayList<t>实现了List<t>接口，它可以向上转型为List<t>：</t></t></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>即类型ArrayList<t>可以向上转型为List<t>。</t></t></p><p>要特别注意：不能把ArrayList<integer>向上转型为ArrayList<number>或List<number>。</number></number></integer></p><h1 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h1><p>使用泛型时，把泛型参数<t>替换为需要的class类型，例如：ArrayList<string>，ArrayList<number>等；</number></string></t></p><p>可以省略编译器能自动推断出的类型，例如：List<string> list = new ArrayList&lt;&gt;();；</string></p><p>不指定泛型参数类型时，编译器会给出警告，且只能将<t>视为Object类型；</t></p><p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p><h1 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h1><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如ArrayList<t>，我们很少需要编写泛型类。</t></p><p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p><p>可以按照以下步骤来编写一个泛型类。</p><p>首先，按照某种类型，例如：String，来编写类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，，把特定类型String替换为T，并申明<t>：</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>编写泛型时，需要定义泛型类型<t>；</t></p></li><li><p>静态方法不能引用泛型类型<t>，必须定义其他类型（例如<k>）来实现静态泛型方法；</k></t></p></li><li><p>泛型可以同时定义多种类型，例如Map&lt;K, V&gt;。</p></li></ul><h1 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h1><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p><p>例如，我们编写了一个泛型类Pair<t>，这是编译器看到的代码：</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，Java使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型<t>视为Object；</t></li><li>编译器根据<t>实现安全的强制转型。</t></li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">"Hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">String first = p.getFirst();</span><br><span class="line">String last = p.getLast();</span><br></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair p = <span class="keyword">new</span> Pair(<span class="string">"Hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">String first = (String) p.getFirst();</span><br><span class="line">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure><p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。</p><p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限,擦拭法决定了泛型<t>：</t></p><ul><li>不能是基本类型，例如：int；</li><li>不能获取带泛型类型的Class，例如：Pair<string>.class；</string></li><li>不能判断带泛型类型的类型，例如：x instanceof Pair<string>；</string></li><li>不能实例化T类型，例如：new T()。</li></ul><p>泛型方法要防止重复定义方法，例如：public boolean equals(T obj)；</p><p>子类可以获取父类的泛型类型<t>。</t></p><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210913105530.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是泛型&quot;&gt;&lt;a href=&quot;#什么是泛型&quot; clas</summary>
      
    
    
    
    <category term="CS-Language" scheme="https://blog.haxianhe.com/categories/CS-Language/"/>
    
    
    <category term="java" scheme="https://blog.haxianhe.com/tags/java/"/>
    
    <category term="《破壁 Java》" scheme="https://blog.haxianhe.com/tags/《破壁-Java》/"/>
    
  </entry>
  
  <entry>
    <title>以史为鉴 - 读《原则》</title>
    <link href="https://blog.haxianhe.com/2021/09/08/Book-Notes-Self/%E5%8E%9F%E5%88%99/"/>
    <id>https://blog.haxianhe.com/2021/09/08/Book-Notes-Self/%E5%8E%9F%E5%88%99/</id>
    <published>2021-09-08T04:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.756Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210908170405.png" alt></p><blockquote><p>当你阅读我的故事时，请努力透过故事和我这个人，看到潜在的因果关系，看到我做的选择和这些选择的后果，看到我从中学到了什么，以及我在总结经验后是如何改变决策方式的。你要问自己要什么，将那些得到了你想要的东西的人作为范例，努力分析出潜藏在他们成就背后的因果关系模式，这样你就能应用这些模式，帮助实现自己的目标。</p></blockquote><h1 id="思考、总结、使用原则"><a href="#思考、总结、使用原则" class="headerlink" title="思考、总结、使用原则"></a>思考、总结、使用原则</h1><p>在回顾我的个⼈经历时，想想我的看法是如何改变的，是件很有意思的事。</p><p>最初的时候，我遇到的每⼀个波折，⽆论是在市场上还是在⽣活中，都显得⾮常重⼤⽽且⼗万⽕急，就像某种独特的⽣死攸关的经历，不断地朝我涌来。</p><p>积累了更多经验以后，我开始把每次遭遇视为“类似情境的重现”，我能以更平静、更严谨的⽅式应对，就像⼀位⽣物学家在丛林⾥遇到⼀只可怕的动物时⼀样：⾸先确定它的种属，利⽤已有的知识预测它的⾏为，然后合理地做出反应。当我⾯对遇到过的某类情况时，我就利⽤在此前类似经历中总结的原则。但当我遇到从未见过的事情时，我会⼤吃⼀惊。在研究所有这些痛苦的⾸次体验时，我意识到，尽管我没经历过这些事，但其中的⼤多数都有其他⼈在其他时间、其他地⽅经历过。这⼀认识让我对历史抱有⼀种健康的尊重感，渴望对现实的机理形成普遍性的理解，并希望总结出永恒、普适的应对问题的原则。</p><p>看到同样的事情反复发⽣，我开始把现实视为⼀部华丽的永动机，⼀些原因引起⼀些结果，这些结果又成为原因，循环往复。我意识到尽管现实不完美，但⾄少我们要直⾯它，因此我在现实中遇到任何问题或挫折时，都不会抱怨，⽽是通过更具建设性的⽅式找到有效的应对⽅法。我逐渐明⽩，我的遭遇是对我的个性和创造⼒的考验。我逐渐领悟到，在⼀个如此伟⼤的系统⾥，我不过是渺⼩的匆匆过客，因此知道如何与这个系统良好互动，对我和系统都是有益的。在形成这个视⾓的过程中，我开始以⼀种截然不同的⽅式体会痛苦的时刻。我不会感觉沮丧或透不过⽓，⽽是把痛苦视为⼤⾃然的提醒，告诉我有⼀些重要的东西需要我去学习。体验痛苦，然后探索⼤⾃然希望通过痛苦给我什么教益，开始成为我的⼀项游戏。这项游戏我做得越多就越擅长，也就越不会对这些情况感到痛苦，同时思考、总结出原则、利⽤原则获得回报的过程也变得越来越有收获。我学会了喜爱⾃⼰的痛苦，我想这是⼀种健康的视⾓，就像学会喜爱锻炼⾝体⼀样（这⼀点我⽬前还做不到）。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>《原则》这本书是在桥水基金创始人 瑞·达利欧 的个人原则基础上组合形成的，这本书里介绍了很多瑞·达利欧个人在生活和工作上总结提炼的原则，这些内容对大多数人价值有限，这里的原则的本质只是一个人过去一段时间内的经验总结，有其时空局限性。</p><p><strong>相比于书中介绍的原则，我对瑞·达利欧这种提炼总结个人原则的习惯更感兴趣，其实也就是当下互联网公司中的case study或者叫故障复盘，只不过瑞·达利欧将自己过去case study中具有的共性内容提炼总结了出来，形成了原则。</strong></p><p><strong>基于以上思考，我不禁想到历史，有这样一句话“历史总是一遍有一遍的重演”。中国有几千年的历史沉淀，我们完全可以从这些历史宝藏里提炼总结出更加具有时空效力的原则，以史为鉴！！</strong></p><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210908170405.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当你阅读我的故事时，请努力透过故事和我这</summary>
      
    
    
    
    <category term="Book-Notes" scheme="https://blog.haxianhe.com/categories/Book-Notes/"/>
    
    
    <category term="自我管理" scheme="https://blog.haxianhe.com/tags/自我管理/"/>
    
  </entry>
  
  <entry>
    <title>人性本善-读《非暴力沟通》</title>
    <link href="https://blog.haxianhe.com/2021/09/08/Book-Notes-Psycholog/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/"/>
    <id>https://blog.haxianhe.com/2021/09/08/Book-Notes-Psycholog/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</id>
    <published>2021-09-07T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.756Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210908142542.png" alt></p><p>《非暴力沟通》<br>作者：【美】Marshall B.Rosenberg<br>译者：阮胤华<br>出版社：北京，华夏出版社，2013年</p><hr><h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><p>本书详细阐述了非暴力沟通的核心思想，而且还对非暴力沟通的四个要素做了细致的说明。这些沟通要素揭示了暴力行为的形成原理，也为避免暴力沟通提供了切实可行的方法。比如要想让语言变得平和，你需要表达客观事实，而不是对他人进行“道德评判”；面对自己的内心诉求，你需要去请求他人，而不是“强人所难”。暴力看似无处不在，但只要你懂得如何改变自己的价值取向，就能让人生变得更加美好。</p><p>这本书分享了三个重点内容：</p><ul><li>第一个重点内容是，从表面上来看，平等的交流是如何演变成暴力行为的；</li><li>第二个重点内容是，在暴力行为的背后，隐藏着什么样的深层次原因；</li><li>第三个重点内容是，如何运用非暴力沟通的四要素，来改变自己的人生走向？</li></ul><h1 id="从表面上来看，交流是如何演变成暴力行为的？"><a href="#从表面上来看，交流是如何演变成暴力行为的？" class="headerlink" title="从表面上来看，交流是如何演变成暴力行为的？"></a>从表面上来看，交流是如何演变成暴力行为的？</h1><p>卢森堡博士看来，有四个原因让我们的日常交流，演变成了暴力行为。这四个原因分别是：<strong>道德评判、进行比较、回避责任和强人所难</strong>。</p><p><strong>道德评判</strong>：有点像是用自己的价值观给别人贴标签。比如说，你上班的时候，每天都要擦办公桌，才会觉得桌子是干净的。可是你的同事小王呢，对自己的要求不高，一个星期就擦一次，也觉得挺干净了。结果呢，你马上就给小王贴上了“邋遢”和“懒惰”的标签。贴标签就是道德评判。这一刻，你的偏见也就产生了，这种偏见会阻碍你和同事进行平和的交流。</p><p><strong>进行比较</strong>：一个人总是和别人攀比，始终不能平心静气地看待别人，当然也就不能和别人处于一个平等的关系。关系不平等，还谈什么交流呢？</p><p><strong>回避责任</strong>：是指我们的表达方式，经常会忽略掉内心的情感根源。</p><p><strong>强人所难</strong>：很多中国家长喜欢把自己的意愿强加给孩子，强迫孩子们去做一些事情。父母强迫孩子做他不愿意，或者没有能力做到的事情，这显然也是一种暴力。</p><h1 id="在暴力行为的背后，隐藏着什么样的深层次原因？"><a href="#在暴力行为的背后，隐藏着什么样的深层次原因？" class="headerlink" title="在暴力行为的背后，隐藏着什么样的深层次原因？"></a>在暴力行为的背后，隐藏着什么样的深层次原因？</h1><p>一个对世界充满恶意的人，看什么都不顺眼，甚至他有时候还会想去报复社会。一个怀着这种仇恨心态的人，在生活中肯定是经常陷入暴力沟通了。</p><p>当一个人老是陷入暴力冲突当中，问题的关键有可能不在于他说话的方式，而在于他对自己和这个世界的看法。</p><p>其实，不论是对自己的看法，还是对世界的看法，都可以被看成是你的价值取向。自古以来我们就流传着两种价值取向，性本善和性本恶。在卢森堡博士看来，一切暴力行为的背后，其实都隐藏着性本恶的价值取向。<strong>当你认为人的本性是丑陋的、冷酷的，那么你自然会用相对应的暴力方式去应对。这时候你就会陷入暴力当中。而当你认为人的本性是善良的、积极的，那么你就会用相对应的温柔的方式去应对。你就自然会离暴力因素越来越远。</strong></p><h1 id="如何运用非暴力沟通的四要素，来改变自己的人生走向？"><a href="#如何运用非暴力沟通的四要素，来改变自己的人生走向？" class="headerlink" title="如何运用非暴力沟通的四要素，来改变自己的人生走向？"></a>如何运用非暴力沟通的四要素，来改变自己的人生走向？</h1><p>你对这个世界的看法，必然是你人生经历的结果。比如说，一个从小就被父亲家暴的小孩，长大后，他的价值取向很有可能会受到父亲的影响。他可能会因为憎恨自己的父亲，进而把报复自己的父亲、甚至是报复整个社会当成是人生目标。一个人活着是为了报复别人，这就是为仇恨而选择了生活，他的人生就会充满暴力。</p><p>但是有时候，一个人就算明明知道了自己的价值取向有问题，也很难纠正过来。因为这种人生经历的影响，太过于根深蒂固，不是一朝一夕可以彻底改变的。在本书作者看来，价值取向的转变，很像是佛教里所说的修行。通过修行，来让你相信这个世界是有爱的，你是为爱选择生活，而不是为了仇恨选择生活。只有让自己放下过去的心理包袱，才能够摆脱掉仇恨，让生活向着光明的方向发展。</p><p>那既然说改变自己是一种修行，具体又该怎么做呢？</p><p>针对这一点，卢森堡博士在书里提出了非暴力沟通的四个要素。<strong>这四个要素分别是：观察、感受、需要和请求</strong>。在日常生活当中，你可以通过这四个要素，来不断提醒自己，让自己的思维方式向着有爱的方向发展。</p><p>我们可以先从语言结构的角度，来理解一下非暴力沟通的这四个要素。</p><p>你平时所有的语言表达，都可以被切分成几个模块。是这些类似原因、结果的模块组合成了你的语言。<strong>而通过非暴力沟通四要素的逻辑来重新组织语言，就是让你的语言结构不再是随意任性的，而是组合成一种平等的、互相尊重的语言</strong>。</p><p>举个简单的例子来说，我交给你一份非常重要的商业机密文件，千叮咛万嘱咐地告诉你一定要保管好，结果呢？你刚答应完，扭头就把文件放在公共会议室，出去吃饭去了。等你回来，我可能会非常生气地说：“<strong>哎，我给你的这么重要的文件，你怎么就随便放在公共会议室啊</strong>？”注意了，这句话是责备别人的，是一种明显的暴力行为。那接下来，让我用非暴力沟通的思维逻辑再来表达一次。</p><p>非暴力沟通的第一个要素是观察，所以我首先观察到的是，你把机密文件放在了公共会议室里；第二个要素是感受，我的感受是什么呢？肯定是觉得首先这么放文件很不安全，其次我会感到很失望，因为我已经嘱咐过你要好好地保管文件，你也答应过我了，可你却没有放心上；第三个要素“需要”和第四个要素“请求”，指的是我先分辨出我需要什么，然后再向你提出请求。</p><p>这样一套思考程序下来，用非暴力沟通语言完整表达的话，就是“<strong>我看见刚才给你的重要文件没收起来，放在公共会议室了，这个我就担心不太安全，会议室里人来人往的，让客户看见就不好了。这么重要的文件既然交给你了，以后还是请你注意妥善保存</strong>。”</p><p>这就是非暴力沟通的语言表达方式。如果你熟悉了这样的语言结构，你和别人的关系会变得互相尊重、更加平等。不管是和人说话也好，反思自己也好，你都可以用这四个要素来检查自己的思维，看看你的思维是出于积极的价值取向，还是消极的价值取向。<strong>不断进行非暴力沟通的修行以后，你会发现，你对这个世界会有了一种性本善的信仰，这种信仰会让你避免暴力，生活在更加有爱的环境中</strong>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>第一个重点内容是，从表面上来看，平等的交流是如何演变成暴力行为的？让交流变成暴力行为的原因有四点，这四点分别是道德评判、进行比较、回避责任和强人所难。从表面上来看，是这四点原因让平等的交流难以实现，也是这四点原因，直接导致了暴力行为；</p><p>第二个重点内容是，在暴力行为的背后，隐藏着什么样的深层次原因？暴力的根本原因，其实是性本恶的价值取向。只有改变这种对世界的消极看法，才能真正帮助你摆脱暴力；</p><p>第三个重点内容是，如何运用非暴力沟通的四要素，来改变自己的人生走向？非暴力沟通的四要素是观察、感受、需要和请求。利用这四个要素，可以检查你平时的思维方式，以及这种思维方式的动机。当你的一切行为，都是出于对善的信仰，暴力也就在你的生活中消失了。</p><p>《非暴力沟通》这本书，讲的既是一种非常实用的沟通方法，同时，也是一种对生活的信仰。许多尝试过非暴力沟通的人，都体会到了非暴力沟通的价值。他们把非暴力沟通的四个要素写成卡片，每当有可能遇到暴力行为的时候，就看一看卡片，提醒自己不要陷入暴力当中，而是要从平等、尊重的角度来看待问题。非暴力沟通的思想，在很多个国家和国际组织里都产生了强烈反响。当越来越多的人学习非暴力沟通以后，他们发现，这个世界并非是冷酷无情的，而是可以通过人们的努力，变得越来越和谐。</p><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210908142542.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;《非暴力沟通》&lt;br&gt;作者：【美】Marshall B.Rosen</summary>
      
    
    
    
    <category term="Book-Notes" scheme="https://blog.haxianhe.com/categories/Book-Notes/"/>
    
    
    <category term="心理学" scheme="https://blog.haxianhe.com/tags/心理学/"/>
    
  </entry>
  
  <entry>
    <title>破壁Java - 注解</title>
    <link href="https://blog.haxianhe.com/2021/09/06/CS-Language-Java/break-java-05/"/>
    <id>https://blog.haxianhe.com/2021/09/06/CS-Language-Java/break-java-05/</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.761Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210906212137.png" alt></p><h1 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h1><ul><li>Annotation是JDK5.0引入的新技术</li><li>Annotation的作用：<ul><li>不是程序本身，可以对程序作出解释（这一点和注释没什么区别）</li><li>可以被其他程序（比如编译器）读取</li></ul></li><li>Annotation的格式<ul><li>注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings（value=“unchecked”）</li></ul></li><li>Annotation在哪里使用？<ul><li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息。我们可以通过反射机制变成实现对这些元数据的访问。</li></ul></li></ul><h1 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h1><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p>作用在代码的注解是</p><ul><li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><p>作用在其他注解的注解(或者说 元注解)是:</p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p>从 Java 7 开始，额外添加了 3 个注解:</p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h1 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h1><p>我们总结一下定义Annotation的步骤：</p><p>第一步，用@interface定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，添加参数、默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。</p><p>第三步，用元注解配置注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。</p><h1 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h1><p>Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置：</p><ul><li>SOURCE类型的注解在编译期就被丢掉了；</li><li>CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；</li><li>RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li></ul><p>如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。</p><p>因此，我们只讨论如何读取RUNTIME类型的注解。</p><p>因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。</p><p>Java提供的使用反射API读取Annotation的方法包括：</p><p>判断某个注解是否存在于Class、Field、Method或Constructor：</p><ul><li>Class.isAnnotationPresent(Class)</li><li>Field.isAnnotationPresent(Class)</li><li>Method.isAnnotationPresent(Class)</li><li>Constructor.isAnnotationPresent(Class)</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure><p>使用反射API读取Annotation：</p><ul><li>Class.getAnnotation(Class)</li><li>Field.getAnnotation(Class)</li><li>Method.getAnnotation(Class)</li><li>Constructor.getAnnotation(Class)</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line">Report report = Person.class.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">int</span> type = report.type();</span><br><span class="line">String level = report.level();</span><br></pre></td></tr></table></figure><p>使用反射API读取Annotation有两种方法。方法一是先判断Annotation是否存在，如果存在，就直接读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    Report report = cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line">Report report = cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="keyword">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(@NotNull @Range(max=<span class="number">5</span>)</span> String name, @NotNull String prefix) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line">Method m = ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        Range r = (Range) anno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        NotNull n = (NotNull) anno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h1><p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。</p><p>我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某个JavaBean中，我们可以使用该注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range</span>(min=<span class="number">1</span>, max=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range</span>(max=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid field: "</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1255945389098144</a></li><li><a href="https://www.bilibili.com/video/BV1p4411P7V3?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1p4411P7V3?p=1</a></li></ul><p><br><br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/haxianhe/image/raw/master/ks-computer-image/20210906212137.png&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;注解的作用&quot;&gt;&lt;a href=&quot;#注解的作用&quot; clas</summary>
      
    
    
    
    <category term="CS-Language" scheme="https://blog.haxianhe.com/categories/CS-Language/"/>
    
    
    <category term="java" scheme="https://blog.haxianhe.com/tags/java/"/>
    
    <category term="《破壁 Java》" scheme="https://blog.haxianhe.com/tags/《破壁-Java》/"/>
    
  </entry>
  
  <entry>
    <title>如何做一个有质量的技术分享【转】</title>
    <link href="https://blog.haxianhe.com/2021/09/03/Summary/summary-06/"/>
    <id>https://blog.haxianhe.com/2021/09/03/Summary/summary-06/</id>
    <published>2021-09-03T04:00:00.000Z</published>
    <updated>2021-11-23T12:50:38.775Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://coolshell.cn/articles/21589.html" target="_blank" rel="noopener">https://coolshell.cn/articles/21589.html</a></p></blockquote><p>分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高度的分享，这个就难了，所谓的有质量和有高度，我心里面的定义有两点：</p><ol><li>分享内容的保鲜期是很长的，</li><li>会被大范围的传递。</li></ol><p>我们团队内每周都在做技术分享，虽然分享的主题都很有价值，但是分享的质量参差不齐，所以，想写下这篇文章 。供大家参考。</p><p>首先，我们先扪心自问一下，我们自己觉得读到的好的技术文章是什么？我不知道大家的是什么，我个人认为的好的文章是下面这样的：</p><ul><li><p><strong>把复杂的问题讲解的很简单也很清楚</strong>。比如我高中时期读到这本1978年出版的《<a href="https://book.douban.com/subject/1441922/" target="_blank" rel="noopener">从一到无穷大</a>》，用各种简单通俗通懂的话把各种复杂的科学知识讲的清清楚楚。还有看过的几本很好的书，有一本是《<a href="https://book.douban.com/subject/5273955/" target="_blank" rel="noopener">Windows程序设计</a>》，从一个hello world的程序开始一步一步教你Windows下的原生态编程。</p></li><li><p><strong>有各种各样的推导和方案的比较，让你知其然知其所以然</strong>。有了不同方案的比较，才可能让人有全面的认识。这个方面的经典作著是《<a href="https://book.douban.com/subject/5387403/" target="_blank" rel="noopener">Effective C++</a>》。</p></li><li><p><strong>原理、为什么、思路、方法论会让人一通百通</strong>。这里面最经典的恐怕就是《<a href="https://book.douban.com/subject/5387403/" target="_blank" rel="noopener">十万个为什么</a>》了，在计算机方面也有几本经典书，有《<a href="https://book.douban.com/subject/1467587/" target="_blank" rel="noopener">Unix编程艺术</a>》、《<a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">设计模式</a>》、《<a href="https://book.douban.com/subject/1230413/" target="_blank" rel="noopener">深入理解计算机系统</a>》等书，以及《<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K Problem</a>》等很多技术论文。</p></li></ul><p>其实，从教科书，到专业书，再到论文，都有上面这些不错的特质。</p><p>所以，如果你想做一个好的技术分享的话，下面是我总结出来的方法，供你参考。</p><ul><li><strong>先描述好一个问题</strong>。这样能够听众带入进来，如果这个问题是他们感同身受的，那是最好了。千万不要一上来就说What，或是直接冲进答案里。这样的分享是在灌输和填鸭。把Why说清楚。没有Why，直接谈What的技术分享，通常来说价值不大。</li><li><strong>How比What重要</strong>。在讲How的时候，也就是如何解这个问题。<br>先要把问题模型说清楚，有了问题模型这个框框后，方案才有意义。<br>然后要有不同技术的比较。有了比较后，听众才会更相信你。<br>直接上What的技术细节，其实没有太大意义。</li><li><strong>一定要有Best Practice或方法论总结</strong>，否则上不了档次的。也就是分享中大家可以得到的重要收获。</li></ul><p>说明了这个模型就是：<strong>问题 –&gt; 方案 –&gt; 总结</strong>。这其中是有一定的心理学模型的，具体表现如下：</p><ul><li>用问题来吸引受众，带着受众来一起思考</li><li>用问题模型来框住受众的思考范围，让受众聚焦</li><li>给出几种不同的解决方案，比较他们的优缺点，让受众有一种解决问题的参与感。</li><li>最后，给出最佳实践，方法论或套路，因为有了前三步的铺垫，受众欣然接受。</li><li>整个过程会让受众有强烈的成长感和收获感。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://coolshell.cn/articles/21589.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.cn/articles/21589.ht</summary>
      
    
    
    
    <category term="Summary" scheme="https://blog.haxianhe.com/categories/Summary/"/>
    
    
    <category term="技术思考" scheme="https://blog.haxianhe.com/tags/技术思考/"/>
    
  </entry>
  
</feed>
